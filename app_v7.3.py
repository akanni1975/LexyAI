# -*- coding: utf-8 -*-
"""App_v5.5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E0X9U1nI-2YPh5tNkrh-K8g3lFZhDf9L
"""

import streamlit as st
import pandas as pd
from PIL import Image
import re
from difflib import SequenceMatcher
import os
import csv
from datetime import datetime


LOG_PATH = "failure_log.csv"

GENERIC_TOKENS = {"pain", "ache", "aches", "soreness", "discomfort",
                  "rash", "rashes", "fever", "cough", "vomiting",
                  "diarrhea", "dizziness", "fatigue", "weakness"}

# New: treat ‚Äútenderness‚Äù as a generic synonym so ‚Äúbreast pain‚Äù ‚âà ‚Äúbreast tenderness‚Äù
GENERIC_SYNONYMS = {"pain", "ache", "aches", "soreness", "discomfort", "tenderness",
                    "rash", "rashes", "fever", "cough", "vomiting",
                    "diarrhea", "dizziness", "fatigue", "weakness"}

GENERIC_SYNONYMS |= {"hives","urticaria","exanthem","dermatitis","eruption","itch","itchy","itching","pruritus"}

# Map each generic to common synonyms seen in the DB
GENERIC_FAMILY = {
    "pain": {"pain","ache","aches","soreness","discomfort","tenderness"},
    "rash": {"rash","rashes","hives","urticaria","exanthem","dermatitis","eruption"},
    "fever": {"fever","pyrexia","temperature"},
    "cough": {"cough","coughing"},
    "vomiting": {"vomiting","vomit","emesis","throwing","throwing up"},
    "diarrhea": {"diarrhea","diarrhoea","loose","watery","stools","stool"},
    "dizziness": {"dizziness","vertigo","lightheadedness"},
    "fatigue": {"fatigue","tiredness","malaise"},
    "weakness": {"weakness","asthenia"},
}

WEAK_ANCHORS = {"skin", "body", "area", "surface"}

def log_failure(record: dict):
    file_exists = os.path.isfile(LOG_PATH)
    with open(LOG_PATH, "a", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=list(record.keys()))
        if not file_exists:
            writer.writeheader()
        writer.writerow(record)

def analytics_page():
    st.header("üìä App Failure Report")
    if not os.path.isfile(LOG_PATH):
        st.info("No failures logged yet.")
        return

    df = pd.read_csv(LOG_PATH, parse_dates=["timestamp"])
    st.subheader("Recent Failures")
    st.dataframe(df.sort_values("timestamp", ascending=False).head(20))

    st.subheader("Failures by Reason")
    counts = df["reason"].value_counts().reset_index()
    counts.columns = ["Reason","Count"]
    st.table(counts)

def stem(word: str) -> str:
    w = word.lower().strip()
    for suf in ("ing", "ion", "ed", "s", "ness", "able"):
        if w.endswith(suf):
            return w[: -len(suf)]
    return w

st.set_page_config(page_title="LEXY... LexMedical AI Triage System", page_icon="ü©∫", layout="centered")

# --- Mobile-friendly, high-contrast styles ---
st.markdown("""
<style>
.report-block {
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 10px;
  padding: 16px;
  font-size: 1rem;
  line-height: 1.6;
  color: #2b0000;
  word-wrap: break-word;
  overflow-wrap: anywhere;
}
.report-block--ok {
  background-color: #d4edda;
  border-color: #c3e6cb;
  color: #062b0a;
}            
.report-block--warn {
  background-color: #fff3cd;
  border: 1px solid #ffeeba;
  color: #3a2e00;
}
.emergency-block {
  margin-top: 16px;
  padding: 14px;
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 10px;
  font-weight: 600;
  font-size: 1rem;
  line-height: 1.6;
  color: #2b0000;
  word-wrap: break-word;
  overflow-wrap: anywhere;
}
@media (max-width: 640px) {
  .report-block, .emergency-block {
    font-size: 1.05rem;
    line-height: 1.7;
    padding: 18px;
  }
  .stButton > button { width: 100% !important; }
}
</style>
""", unsafe_allow_html=True)

# Initialize session state safely
if 'free_input_mode' not in st.session_state:
    st.session_state.free_input_mode = False
if 'page' not in st.session_state:
    st.session_state.page = "welcome"
if 'user_data' not in st.session_state:
    st.session_state.user_data = {}
if 'current_condition' not in st.session_state:
    st.session_state.current_condition = None
if 'confirmed_risks' not in st.session_state:
    st.session_state.confirmed_risks = []
if 'matched_conditions' not in st.session_state:
    st.session_state.matched_conditions = pd.DataFrame()
if 'logged_in' not in st.session_state:
    st.session_state.logged_in = False

@st.cache_data
def load_data():
    df = pd.read_excel("SymptomBotDB.xlsx")
    # ‚îÄ‚îÄ Normalize every header: remove leading/trailing whitespace ‚îÄ‚îÄ
    df.columns = df.columns.str.strip()
    return df
# --- Free-text normalization driven by Excel (FreeTextMap sheet) ---

@st.cache_data
def load_freetext_map() -> dict:
    """
    Reads SymptomBotDB.xlsx -> sheet 'FreeTextMap' with columns:
      from_phrase, to_phrase  (case-insensitive)
    Returns dict {from_phrase_lower: to_phrase_lower}.
    If the sheet is missing, returns {} (no-op).
    """
    try:
        df_map = pd.read_excel("SymptomBotDB.xlsx", sheet_name="FreeTextMap")
        df_map.columns = df_map.columns.str.strip().str.lower()
        if not {"from_phrase","to_phrase"}.issubset(df_map.columns):
            return {}
        # build lowercase map, drop blanks
        m = {}
        for _, r in df_map.iterrows():
            fp = str(r["from_phrase"]).strip().lower()
            tp = str(r["to_phrase"]).strip().lower()
            if fp and tp and fp != "nan" and tp != "nan":
                m[fp] = tp
        return m
    except Exception:
        return {}

FT_MAP = load_freetext_map()

# c) fuzzy-stem match across token pairs (safer)
def ok_pair(us, ds):
    # ignore very short tokens for fuzzy; exact/substring already handled earlier
    if len(us) < 4 or len(ds) < 4:
        return False
    # require same starting letter OR substring relation to avoid heart‚âàear/hurt
    if not (us[0] == ds[0] or us in ds or ds in us):
        return False
    return SequenceMatcher(None, us, ds).ratio() >= 0.80  # was 0.65


def normalize_free_text(raw: str) -> str:
    """
    Minimal, safe normalization:
      - lowercase + trim
      - unify curly quotes
      - apply FreeTextMap replacements (longest-first)
      - a couple high-impact typo/alias fixes
    Returns a SINGLE normalized string you feed into your existing matcher.
    """
    if not raw:
        return ""
    text = raw.strip().lower()

    # normalize curly quotes to ascii to avoid miss matches
    text = (text
            .replace("‚Äô", "'")
            .replace("‚Äò", "'")
            .replace("‚Äú", '"')
            .replace("‚Äù", '"'))

    # tiny typo fix that bites often
    text = text.replace("heatbeat", "heartbeat")

    # Apply Excel-driven phrase replacements, longest keys first to avoid partial shadowing
    if FT_MAP:
        for k in sorted(FT_MAP.keys(), key=len, reverse=True):
            if k in text:
                text = text.replace(k, FT_MAP[k])

    return text


def load_logo():
    return Image.open("logo.png")

db = load_data()
logo = load_logo()

# ===== Body-part synonyms ‚Üí category hints (resolved to DB labels) =====

def _cat_norm(s: str) -> str:
    """Canonicalize for matching category names (lowercase, strip, normalize quotes)."""
    return str(s).strip().lower().replace("‚Äô", "'").replace("‚Äò", "'")

# Build map of canonical‚Üíexact label from the DB (so hints always resolve to real labels)
CAT_CANON = {}
for c in db["Primary Category"].dropna().astype(str).unique():
    key = _cat_norm(c)
    # First one wins; we want the exact label as it appears in the DB
    CAT_CANON.setdefault(key, c)

# Tight, human-curated body-part aliases with intended category hints.
# ‚ö†Ô∏è Hints are written using the **exact** strings from your DB above.
BODY_PART_SYNONYMS = {
    # Head & neck
    "head":         {"aliases": {"head", "skull"}, "category_hints": ["Gen. Body Pain or Discomfort", "Injury and Bites"]},
    "face":         {"aliases": {"face","facial","cheek","cheeks","jaw","jawbone","chin"}, "category_hints": ["Ear, Nose and Throat","Dental","Skin or Rashes","Eye Irritation"]},
    "scalp":        {"aliases": {"scalp"}, "category_hints": ["Skin or Rashes"]},
    "eye":          {"aliases": {"eye","eyes","eyelid","eyelids"}, "category_hints": ["Eye Irritation"]},
    "ear":          {"aliases": {"ear","ears"}, "category_hints": ["Ear, Nose and Throat"]},
    "nose":         {"aliases": {"nose","nostril","nostrils"}, "category_hints": ["Ear, Nose and Throat","Breathing or Cough"]},
    "throat":       {"aliases": {"throat","tonsil","tonsils"}, "category_hints": ["Ear, Nose and Throat","Breathing or Cough"]},
    "mouth_teeth":  {"aliases": {"mouth","gum","gums","tooth","teeth","tongue","lip","lips"}, "category_hints": ["Dental","Ear, Nose and Throat"]},
    "neck":         {"aliases": {"neck","nape"}, "category_hints": ["Gen. Body Pain or Discomfort","Swelling"]},

    # Chest, back, abdomen
    "chest":        {"aliases": {"chest","rib","ribs"}, "category_hints": ["Breathing or Cough","Gen. Body Pain or Discomfort","Emergency"]},
    "breast":       {"aliases": {"breast","breasts","nipple","nipples","areola"}, "category_hints": ["Women‚Äôs Health","Swelling"]},
    "back":         {"aliases": {"back","upper back","lower back","waist"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "abdomen":      {"aliases": {"abdomen","abdominal","belly","tummy","stomach","tommy"}, "category_hints": ["Stomach & Digestion"]},
    "flank_side":   {"aliases": {"flank","side"}, "category_hints": ["Thirst & Urination","Stomach & Digestion"]},
    "hip":          {"aliases": {"hip","hips"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "groin":        {"aliases": {"groin","crotch"}, "category_hints": ["Urinary & Sexual Health","Men‚Äôs Health","Women‚Äôs Health"]},

    # Buttocks & anorectal
    "buttocks":     {"aliases": {"buttocks","butt","bum","backside","behind","ass"}, "category_hints": ["Rectal & Bowel Health","Skin or Rashes"]},
    "anus_rectum":  {"aliases": {"anus","anal","rectum","rectal"}, "category_hints": ["Rectal & Bowel Health"]},

    # Upper limbs
    "shoulder":     {"aliases": {"shoulder","shoulders","collarbone","clavicle"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "arm":          {"aliases": {"arm","arms"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites","Swelling"]},
    "elbow":        {"aliases": {"elbow","elbows"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "forearm":      {"aliases": {"forearm","forearms"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "wrist":        {"aliases": {"wrist","wrists"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "hand":         {"aliases": {"hand","hands","palm","finger","fingers","thumb","thumbs"}, "category_hints": ["Gen. Body Pain or Discomfort","Skin or Rashes","Injury and Bites"]},

    # Lower limbs
    "leg":          {"aliases": {"leg","legs"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites","Swelling"]},
    "thigh":        {"aliases": {"thigh","thighs","lap"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "knee":         {"aliases": {"knee","knees"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites","Swelling"]},
    "calf":         {"aliases": {"calf","calves"}, "category_hints": ["Gen. Body Pain or Discomfort","Swelling"]},
    "shin":         {"aliases": {"shin","shins"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "ankle":        {"aliases": {"ankle","ankles"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites","Swelling"]},
    "foot":         {"aliases": {"foot","feet","heel","heels","sole","toes","toe"}, "category_hints": ["Gen. Body Pain or Discomfort","Skin or Rashes","Injury and Bites","Swelling"]},

    # Genitals (gender gating happens later)
    "male_genitals":   {"aliases": {"penis","testicle","testicles","scrotum","balls","manhood","dick"}, "category_hints": ["Men‚Äôs Health","Urinary & Sexual Health"]},
    "female_genitals": {"aliases": {"vagina","vaginal","vulva","labia","clitoris","womanhood","private part"}, "category_hints": ["Women‚Äôs Health","Urinary & Sexual Health"]},

    # Skin (general)
    "skin":         {"aliases": {"skin"}, "category_hints": ["Skin or Rashes"]},
}

# Resolve every hint to the exact DB label; drop/flag any that don‚Äôt resolve
BP_ALIAS_TO_HINTS = {}
_BAD_HINTS = []  # if any, fix the spelling/spacing in BODY_PART_SYNONYMS

for _canon, data in BODY_PART_SYNONYMS.items():
    for alias in data["aliases"]:
        resolved = set()
        for hint in data["category_hints"]:
            key = _cat_norm(hint)
            real = CAT_CANON.get(key)
            if real is None:
                _BAD_HINTS.append((alias, hint))
            else:
                resolved.add(real)
        if resolved:
            BP_ALIAS_TO_HINTS[alias.lower()] = resolved

# Optional: print unresolved hints to Streamlit sidebar (visible only to admins/devs)
if _BAD_HINTS:
    st.sidebar.warning("Unrecognized category_hints in BODY_PART_SYNONYMS (check spelling):")
    for alias, hint in _BAD_HINTS:
        st.sidebar.write(f"alias='{alias}'  hint='{hint}'  ‚Üí NOT IN DB")
# ===== End body-part hints =====


# --- UTILITY FUNCTIONS ---


def is_gender_allowed(primary_category, gender, suppress_error=False):
    primary_category = primary_category.replace("‚Äô", "'")
    WOMEN_SPECIFIC = {
        "Women's Health", "Pelvic Inflammatory Disease", "Breast Lump",
        "Cervical Cancer", "Menopause", "Fibroids", "Heavy Menstrual Bleeding",
        "Yeast Infection", "Bacterial Vaginosis", "Endometriosis", "PCOS",
        "Pelvic Organ Prolapse", "Ovarian Cyst", "Ectopic Pregnancy"
    }
    MEN_SPECIFIC = {
        "Men's Health", "Prostatitis", "Testicular Torsion",
        "Benign Prostatic Hyperplasia", "Varicocele", "Balanitis"
    }
    if gender == "Male" and primary_category in WOMEN_SPECIFIC:
        if not suppress_error:
            st.error("This category is not available for your selected gender")
        return False
    if gender == "Female" and primary_category in MEN_SPECIFIC:
        if not suppress_error:
            st.error("This category is not available for your selected gender")
        return False
    return True

def display_grid(items, cols=3):
    rows = [items[i:i + cols] for i in range(0, len(items), cols)]
    for row in rows:
        columns = st.columns(len(row))
        for col, item in zip(columns, row):
            with col:
                if st.button(item, use_container_width=True):
                    return item
    return None

def generate_report():
    condition = st.session_state.current_condition
    user = st.session_state.user_data
    report = f"""
LEXAI SYMPTOM CHECKER REPORT
============================

Patient Details:
- Age: {user.get('age', 'N/A')}
- Gender: {user.get('gender', 'N/A')}

Assessment:
- Likely Condition: {condition['Condition'] if condition is not None else 'N/A'}
- Risk Factors: {', '.join(st.session_state.confirmed_risks) if st.session_state.confirmed_risks else 'None'}

Recommendation:
{condition['Escalated Recommendation' if st.session_state.get('is_high_risk') else 'Default Recommendation'] if condition is not None else ''}
"""
    return report

def similarity(a, b):
    return SequenceMatcher(None, a, b).ratio()

def match_conditions_by_symptoms(input_text, db):
    input_symptoms = [sym.strip().lower() for sym in input_text.split(",") if sym.strip()]
    matched_conditions = []
    for _, row in db.iterrows():
        db_symptoms = [sym.lower().strip() for sym in str(row["Symptoms"]).split(",") if sym.strip()]
        for user_sym in input_symptoms:
            for db_sym in db_symptoms:
                if user_sym in db_sym or db_sym in user_sym or similarity(user_sym, db_sym) >= 0.65:
                    matched_conditions.append(row)
                    break
            else:
                continue
            break
    return pd.DataFrame(matched_conditions).drop_duplicates()

def login_page():
    st.title("Lexy- Carekonnect Symptom Checker Login")

    # Create a form for login
    with st.form("login_form"):
        password = st.text_input("Enter Password", type="password")
        submit_button = st.form_submit_button("Login")

    # Check password
    if submit_button:
        if password == "lexmedical":
            st.session_state.logged_in = True
            st.session_state.page = "welcome"
            st.rerun()
        else:
            st.error("Incorrect password. Please try again.")




def welcome_page():
    # ‚îÄ‚îÄ‚îÄ 1) Inject custom CSS for styling ‚îÄ‚îÄ‚îÄ
    st.markdown("""
    <style>
      /* Center and size the logo container */
      .logo-container {
        text-align: center;
        margin-bottom: 1.5rem;
      }
      /* Title styling */
      .welcome-title {
        text-align: center;
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 1rem;
      }
      /* Body text styling */
      .welcome-text {
        max-width: 600px;
        margin: 0 auto 2rem auto;
        font-size: 1.1rem;
        line-height: 1.6;
        color: #444;
      }
      /* Button sizing and coloring */
      .stButton > button {
        width: 220px;
        height: 50px;
        font-size: 1.1rem;
        border-radius: 8px;
        border: none;
        margin-top: 1rem;
      }
      .stButton > button[disabled] {
        background-color: #bbb !important;
        color: #fff !important;
        cursor: not-allowed;
      }
      .stButton > button:not([disabled]) {
        background-color: #e63946 !important;
        color: #fff !important;
      }
      /* Footer styling */
      .footer {
        text-align: center;
        font-size: 0.9rem;
        color: #666;
        margin-top: 3rem;
      }
    </style>
    """, unsafe_allow_html=True)

    # ‚îÄ‚îÄ‚îÄ 2) Logo ‚îÄ‚îÄ‚îÄ
    st.markdown("<div class='logo-container'>", unsafe_allow_html=True)
    st.image(logo, width=120)
    st.markdown("</div>", unsafe_allow_html=True)

    # ‚îÄ‚îÄ‚îÄ 3) Welcome text ‚îÄ‚îÄ‚îÄ
    st.markdown("<div class='welcome-title'>Lexy- AI Based Symptom Checker</div>", unsafe_allow_html=True)
    st.markdown("""
      <div class='welcome-text'>
         <strong>Hi üëã, I‚Äôm Lexy ‚Äî here to help you make sense of your symptoms and feel more in control of your health.</strong><br><br>
        Lexy is an AI Triage tool that helps users better understand their symptoms and suggests next steps‚Äîwhether that‚Äôs self-care, seeing a provider, or seeking urgent help.<br>
        It does not offer medical diagnoses and is not a substitute for care from a qualified health professional.<br><br>
        This tool is not recommended for children under 16, pregnant individuals, or those with multiple health conditions.<br><br>
        <strong>In case of emergency</strong>‚Äîsuch as chest pain, severe bleeding, or difficulty breathing‚Äîplease call emergency services or go to the nearest hospital.
      </div>
    """, unsafe_allow_html=True)

    # ‚îÄ‚îÄ‚îÄ 4) Confirmation checkbox ‚îÄ‚îÄ‚îÄ
    confirm = st.checkbox("I have read and understood the above")

    # ‚îÄ‚îÄ‚îÄ 5) Centered Start button, gated by checkbox ‚îÄ‚îÄ‚îÄ
    _, center, _ = st.columns([1,2,1])
    with center:
        if st.button("Start Symptom Check", disabled=not confirm):
            st.session_state.page = "user_info"
            st.rerun()

    # ‚îÄ‚îÄ‚îÄ 6) Footer ‚îÄ‚îÄ‚îÄ
    st.markdown("<div class='footer'>Powered by LexMedical Services LTD</div>", unsafe_allow_html=True)

    # ‚îÄ‚îÄ Hidden Admin Access (testing only) ‚îÄ‚îÄ
    pwd = st.sidebar.text_input("Dev code", type="password")
    if pwd == "Akinola":  # ‚Üê replace with your own secret
        if st.sidebar.button("View Analytics"):
            st.session_state.page = "analytics"
            st.rerun()

def user_info_page():
    st.image(logo, width=80)
    st.subheader("Before we begin, I‚Äôd like to know a little about you.")

    with st.form("user_info_form"):
        age = st.number_input("Age", min_value=0, max_value=120)
        # ‚Üê‚Äî THIS IS THE NEW ‚ÄúPediatric Mode‚Äù NOTE
        if 0 <= age <= 14:
            st.info("üë∂ Ages 0‚Ää‚Äì‚Ää14 will activate Pediatric mode on the next screen.")

        gender = st.radio("Gender", ["Male", "Female"], horizontal=True)
        conditions = st.text_input(
            "Existing conditions",
            placeholder="Mention any long-term health issues you live with (like asthma or none)"
        )

        submit_col, _ = st.columns([1, 2])
        with submit_col:
            cont = st.form_submit_button("Continue ‚Üí", type="primary")

    back_col, _ = st.columns([1, 2])
    with back_col:
        back = st.button("‚Üê Back")

    if back:
        st.session_state.page = "welcome"
        st.rerun()
    if cont:
        # ‚îÄ‚îÄ Save demographics ‚îÄ‚îÄ
        st.session_state.user_data['age']        = age
        st.session_state.user_data['gender']     = gender
        st.session_state.user_data['conditions'] = conditions

        # ‚îÄ‚îÄ 1) Pediatrics shortcut for ages 0‚Äì14 ‚îÄ‚îÄ
        if 0 <= age <= 14:
            st.session_state.user_data['primary_category'] = "Pediatrics"
            st.session_state.page = "symptom_subcategory"
        else:
            # ‚îÄ‚îÄ Adult/other flow unchanged ‚îÄ‚îÄ
            st.session_state.page = "symptom_category"

        st.rerun()

def symptom_category_page():
    # ‚îÄ‚îÄ‚îÄ 0) Inject CSS for uniform, wrapped, full-width buttons ‚îÄ‚îÄ‚îÄ
    st.markdown(
        """<style>
          .stButton > button {
            width: 100% !important;
            white-space: normal !important;
            word-wrap: break-word !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            min-height: 4rem !important;
            padding: 0.75rem 1rem !important;
          }
        </style>""",
        unsafe_allow_html=True
    )

    # ‚îÄ‚îÄ‚îÄ 1) Logo & heading ‚îÄ‚îÄ‚îÄ
    st.image(logo, width=80)
    st.subheader("Let‚Äôs start with what‚Äôs bothering you today")

    # ‚îÄ‚îÄ‚îÄ 2) Gender guard ‚îÄ‚îÄ‚îÄ
    current_gender = st.session_state.user_data.get('gender')
    if not current_gender:
        st.error("Gender not selected. Please go back.")
        return
    
    # ‚îÄ‚îÄ‚îÄ 2b) Age-aware category list (hide Pediatrics for 15+) ‚îÄ‚îÄ‚îÄ
    current_age = st.session_state.user_data.get('age')

    valid_categories = []
    for cat in db["Primary Category"].unique():

        # Hide Pediatrics for ages 15+
        if (current_age is not None) and (current_age >= 15) and str(cat).strip().lower() == "pediatrics":
            continue
        if is_gender_allowed(cat, current_gender, suppress_error=True):
            valid_categories.append(cat)

   
    # ‚îÄ‚îÄ‚îÄ 3) Render your 3-col grid via display_grid ‚îÄ‚îÄ‚îÄ
    selected = display_grid(valid_categories, cols=3)

    # ‚îÄ‚îÄ‚îÄ 4) Handle a valid selection ‚îÄ‚îÄ‚îÄ
    if selected and is_gender_allowed(selected, current_gender):
        st.session_state.free_input_mode = False
        st.session_state.matched_conditions = pd.DataFrame()
        st.session_state.user_data['primary_category'] = selected
        st.session_state.page = "symptom_subcategory"
        st.rerun()

    # ‚îÄ‚îÄ‚îÄ 5) Free-text fallback ‚îÄ‚îÄ‚îÄ
    if st.button("Can‚Äôt find your symptoms? Enter them here"):
        st.session_state.page = "symptom_free_input"
        st.rerun()

    # ‚îÄ‚îÄ‚îÄ 6) Back button ‚îÄ‚îÄ‚îÄ
    if st.button("‚Üê Back"):
        st.session_state.page = "user_info"
        st.rerun()

def symptom_free_input_page():
    import re
    from collections import defaultdict
    import pandas as pd
    from datetime import datetime

    st.image(logo, width=80)
    st.subheader("What are your symptoms?")
    st.markdown("Use 1‚Äì2 simple symptoms. Separate multiple with commas (e.g., headache, fever, dizziness, leg pain)")

    # ---------- Local helpers (scoped to this function; safe to remove/move later) ----------
    def _ck_normalize(s: str) -> str:
        # keep commas/semicolons for phrase splits; letters/digits/spaces only
        return re.sub(r'\s+', ' ', re.sub(r'[^A-Za-z0-9\s,;]', ' ', str(s).lower())).strip()

    def _ck_tokenize(s: str):
        # tokens are words >=3 letters
        return re.findall(r"[A-Za-z]{3,}", str(s).lower())

    def _ck_stem(token: str) -> str:
        t = token.lower()
        # conservative suffix strip (single pass)
        for suff in ("ness", "ions", "ion", "ing", "ed", "es", "s"):
            if len(t) > 4 and t.endswith(suff):
                t = t[:-len(suff)]
                break
        # y -> i normalization (dizzy -> dizzi)
        if t.endswith("y") and len(t) >= 4:
            t = t[:-1] + "i"
        return t
    
    def _ck_detect_body_part_hints(free_text_norm: str):
        """Return a set of category labels hinted by body-part aliases in the input."""
        hints = set()
        s = f" {free_text_norm} "  # pad for simple phrase detection
        # phrase-level match (handles multi-word aliases like 'lower back')
        for alias, cats in BP_ALIAS_TO_HINTS.items():
            if f" {alias} " in s:
                hints |= cats
        # token-level match (single words)
        for tok in set(_ck_tokenize(free_text_norm)):
            cats = BP_ALIAS_TO_HINTS.get(tok, set())
            hints |= cats
        return hints



    # Minimal curated synonyms (can be expanded later; not exhaustive by design)
    _CK_SYNONYMS = {
        "rash": {"rashes", "hives", "urticaria", "dermatitis", "exanthem"},
        "dizziness": {"dizzy", "lightheaded"},
        "urinate": {"urinating", "urination"},
        "vomit": {"vomiting", "emesis"},
    }

    def _ck_variants(token: str):
        t = token.lower().strip()
        base = {t, _ck_stem(t)}
        infl = set()

        # add/remove simple inflections
        for suff in ("s", "es", "ed", "ing", "ion", "ions", "ness"):
            if t.endswith(suff) and len(t) > len(suff) + 2:
                infl.add(t[:-len(suff)])
            infl.add(t + suff)

        # y <-> i (dizzy -> dizzi)
        if t.endswith("y") and len(t) >= 4:
            infl.add(t[:-1] + "i")

        syn = _CK_SYNONYMS.get(t, set())

        out = base | infl | syn | {_ck_stem(x) for x in (infl | syn)}
        return {x for x in out if len(x) >= 3}

    def _ck_build_row_index(df, pri_col="Primary Category", sym_col="Symptoms"):
        rows = []
        for i, r in df.iterrows():
            cat = _ck_normalize(r.get(pri_col, ""))
            sym = _ck_normalize(r.get(sym_col, ""))
            cat_toks = set(_ck_tokenize(cat))
            sym_toks = set(_ck_tokenize(sym))
            rows.append({
                "idx": i,
                "cat": r.get(pri_col, ""),
                "sym": r.get(sym_col, ""),
                # include both raw token and stem for fast exact/stem checks
                "cat_tokens": set.union(cat_toks, {_ck_stem(t) for t in cat_toks}),
                "sym_tokens": set.union(sym_toks, {_ck_stem(t) for t in sym_toks}),
            })
        return rows

    def _ck_score_categories_and_subset(free_text, df, pri_col="Primary Category", sym_col="Symptoms"):
        # B2 ‚Äì part 1: split normalize & tokenize so we can reuse free_norm
        free_norm = _ck_normalize(free_text)
        tokens    = set(_ck_tokenize(free_norm))
        if not tokens:
            return [], df.iloc[0:0]

        # detect hinted categories from body-part aliases (needs _ck_detect_body_part_hints + BP_ALIAS_TO_HINTS)
        hint_boosts = _ck_detect_body_part_hints(free_norm)

        token_variants = {t: (_ck_variants(t) | {t, _ck_stem(t)}) for t in tokens}
        rows = _ck_build_row_index(df, pri_col=pri_col, sym_col=sym_col)

        from collections import defaultdict
        rows_by_cat = defaultdict(list)
        for r in rows:
            rows_by_cat[r["cat"]].append(r)

        cat_stats = {}
        cat_rows_hit = defaultdict(set)

        # ---- Stage 1: category-name hits (plus body-part boost)
        for cat, rlist in rows_by_cat.items():
            cat_tokens_union = set()
            for r in rlist:
                cat_tokens_union |= r["cat_tokens"]

            cat_hits = 0
            for t in tokens:
                vset = token_variants[t]
                if any((v in cat_tokens_union) for v in vset):
                    cat_hits += 1

            # B2 ‚Äì part 2: apply hint boost
            if cat in hint_boosts:
                cat_hits += 1

            cat_stats[cat] = {"cat_hits": cat_hits, "sym_hits": 0}

        # ---- Stage 2: symptoms hits (unchanged)
        for cat, rlist in rows_by_cat.items():
            sym_hits = 0
            for r in rlist:
                sym_tokens = r["sym_tokens"]
                row_hit = False
                for t in tokens:
                    vset = token_variants[t]
                    if any((v in sym_tokens) for v in vset):
                        row_hit = True
                        break
                if row_hit:
                    sym_hits += 1
                    cat_rows_hit[cat].add(r["idx"])
            cat_stats[cat]["sym_hits"] = sym_hits

        # ---- scoring & selection (unchanged)
        ranking = []
        for cat, stv in cat_stats.items():
            score = 2.0 * stv["cat_hits"] + 1.0 * stv["sym_hits"]
            ranking.append((cat, score, len(cat_rows_hit[cat])))
        ranking.sort(key=lambda x: (x[1], x[2]), reverse=True)

        valid_cats  = {cat for (cat, score, _n) in ranking if score >= 1.0}
        subset      = df.loc[[r["idx"] for r in rows if r["cat"] in valid_cats]] if valid_cats else df.iloc[0:0]
        ordered_cats = [cat for (cat, score, _n) in ranking if score >= 1.0]
        return ordered_cats, subset
        # ---------- End local helpers ----------

    # ‚Äî Wrap input & submit in a form so Enter works ‚Äî
    with st.form("free_input_form"):
        symptom_input = st.text_input("Your symptoms:")
        search = st.form_submit_button("Search Symptoms")

    if search:
        # ===== CK: Category-first free-text matching =====
        if not symptom_input.strip():
            st.warning("Please enter at least one symptom to search.")
            return

        # Use your DataFrame 'db' and expected columns
        ordered_cats, subset = _ck_score_categories_and_subset(symptom_input, db,
                                                               pri_col="Primary Category",
                                                               sym_col="Symptoms")

        if subset.empty or not ordered_cats:
            # Log and show the same UX actions as before
            try:
                log_failure({
                    "timestamp": datetime.utcnow().isoformat(),
                    "step":      "free_text_match_ck",
                    "input":     symptom_input,
                    "reason":    "no_symptom_match"
                })
            except Exception:
                pass

            st.warning("‚ùóÔ∏è ‚ÄúLet‚Äôs try that again. We couldn‚Äôt find a close match yet. Try one or two simple symptoms (e.g., rash, fever, cough) or pick a body area. You can also speak with a doctor.")
            if st.button("Try Again"):
                st.rerun()
            if st.button("Speak to a Doctor"):
                st.session_state.page = "fallback_page"
                st.rerun()
            if st.button("Start Over"):
                st.session_state.clear()
                st.session_state.page = "welcome"
                st.rerun()
            return

        # Success: save results & advance (retain UI/UX flow)
        st.session_state.free_input_mode            = True
        st.session_state.matched_conditions         = subset
        st.session_state.user_data['free_symptoms'] = symptom_input
        st.session_state.free_primary_ranking       = ordered_cats  # ordered by relevance score
        st.session_state.page                       = "symptom_primary_category_freeinput"
        st.rerun()
        # ===== End CK block =====

    # ‚Äî Back button outside the form ‚Äî
    if st.button("‚Üê Back"):
        st.session_state.page = "symptom_category"
        st.rerun()



def symptom_primary_category_freeinput_page():
    # ‚îÄ‚îÄ Guard: only allow free-text category pick when we actually have matches ‚îÄ‚îÄ
    if not st.session_state.get("free_input_mode") or st.session_state.matched_conditions.empty:
        # fall back to the normal category picker
        st.session_state.page = "symptom_category"
        st.rerun()

    st.image(logo, width=80)
    st.subheader("What feels closest to how you‚Äôre feeling?")

    # now safe: we know matched_conditions exists and has columns
    subset = st.session_state.matched_conditions
    current_gender = st.session_state.user_data.get('gender')
    current_age    = st.session_state.user_data.get('age')

    # --- STRICT dominance filter for generic-only queries ---
    generic_only = bool(st.session_state.user_data.get("generic_only"))
    if generic_only and not subset.empty:
        counts = subset["Primary Category"].value_counts()
        TOP_N = 3
        keep = counts.head(TOP_N).index
        subset = subset[subset["Primary Category"].isin(keep)]


    # Build primary category list in the scored order (not alphabetical)
    ranked = st.session_state.get("free_primary_ranking", [])
    ranked_set = set(ranked)

    # Fall back if ranking missing: preserve previous behavior (alphabetical of subset)
    fallback_order = [cat for cat in subset["Primary Category"].dropna().unique().tolist() if str(cat).strip()]
    ordered = [c for c in ranked if c in subset["Primary Category"].values] or sorted(fallback_order)

    primaries = []
    for cat in ordered:
        # Age/gender gating
        if (current_age is not None) and (current_age >= 15) and str(cat).strip().lower() == "pediatrics":
            continue
        if not is_gender_allowed(cat, current_gender, suppress_error=True):
            continue
        primaries.append(cat)
        

    if not primaries:
        st.warning("We found matches, but none are available for your selected gender/age.")
        if st.button("‚Üê Back"):
            st.session_state.page = "symptom_free_input"
            st.rerun()
        return

    choice = display_grid(primaries, cols=2)
    if choice:
        st.session_state.user_data['primary_category'] = choice
        st.session_state.page = "symptom_subcategory"
        st.rerun()

    if st.button("‚Üê Back"):
        # Back one step in the free-text flow
        st.session_state.page = "symptom_free_input"
        st.rerun()


def symptom_subcategory_page():
    st.image(logo, width=80)
    st.subheader("Let‚Äôs get a bit more specific‚Äîwhat feels closest to what you‚Äôre experiencing?")

    # ‚îÄ‚îÄ Ensure we have a primary category ‚îÄ‚îÄ
    primary = st.session_state.user_data.get("primary_category")
    if not primary:
        st.error("No category selected. Please start over.")
        if st.button("Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # ‚îÄ‚îÄ 3) Pediatric‚Äêmode banner ‚îÄ‚îÄ
    if primary == "Pediatrics":
        st.info("üß∏ Pediatric mode activated‚Äîthese subcategories are age-appropriate for 0‚Äì14 years.")

    # ‚îÄ‚îÄ Rest of your existing flow ‚îÄ‚îÄ
    source = (
        st.session_state.matched_conditions
        if st.session_state.get("free_input_mode", False)
        else db
    )
    filtered = source[source["Primary Category"] == primary]
    subcats = sorted(filtered["SubCategory"].dropna().unique())
    choice = display_grid(subcats, cols=2)
    if choice:
        st.session_state.user_data["subcategory"] = choice
        st.session_state.current_condition = filtered[filtered["SubCategory"] == choice].iloc[0]
        st.session_state.page = "symptom_selection"
        st.rerun()

    if st.button("‚Üê Back"):
        st.session_state.page = (
            "symptom_primary_category_freeinput"
            if st.session_state.get("free_input_mode", False)
            else "symptom_category"
        )
        st.rerun()

def symptom_selection_page():
    st.image(logo, width=80)
    st.subheader("Tell me about your symptoms")

    primary = st.session_state.user_data.get("primary_category")
    subcat  = st.session_state.user_data.get("subcategory")
    if not primary or not subcat:
        st.error("Category or subcategory missing. Please start over.")
        if st.button("Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # 1) Decide source: full DB for normal, matched_conditions for free-text
    source = st.session_state.matched_conditions if st.session_state.get("free_input_mode") else db

    # 2) Filter to your chosen subcategory
    subset = source[
        (source["Primary Category"] == primary) &
        (source["SubCategory"]      == subcat)
    ]

    # 3) Aggregate **all** symptoms across those rows
    options = sorted({
        s.strip()
        for row in subset["Symptoms"].dropna()
        for s   in row.split(",")
    })

    # 4) Render them
    selected = st.multiselect("Select all that apply:", options)

    # 5) Navigation
    col1, col2 = st.columns([1,3])
    with col1:
        if st.button("‚Üê Back"):
            st.session_state.page = "symptom_subcategory"
            st.rerun()
    with col2:
        if st.button("Continue ‚Üí"):
            st.session_state.user_data['selected_symptoms'] = selected
            st.session_state.page = "clarifying_questions"
            st.rerun()

def clarifying_questions_page():
    st.image(logo, width=80)
    st.subheader("Just a couple more quick questions to guide you")

    # 1Ô∏è‚É£ Build the subset of rows for this pathway
    primary = st.session_state.user_data.get("primary_category")
    subcat  = st.session_state.user_data.get("subcategory")

    # pick source: full DB if normal, else your matched free-text subset
    source = db if not st.session_state.get("free_input_mode", False) else st.session_state.matched_conditions

    # filter to the chosen primary/subcategory
    subset = source[
        (source["Primary Category"] == primary) &
        (source["SubCategory"]      == subcat)
    ]
    if subset.empty:
        st.error("No conditions found here‚Äîplease start over.")
        if st.button("Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # 2Ô∏è‚É£ Stage 1: ask every unique CQ1 in this subset
    if not st.session_state.get("cq1_done"):
        cq1s    = list(subset["Clarifying Questions 1"].dropna().unique())
        answers1 = {}
        with st.form("cq1_form"):
            for i, q in enumerate(cq1s, 1):
                ans = st.radio(q, ["Yes", "No"], key=f"cq1_{i}")
                answers1[q] = ans
                answers1[f"cq1_{i}"] = ans   # NEW: store numbered key
            # summary flag for the whole stage
            answers1["cq1"] = "Yes" if any(v == "Yes" for k, v in answers1.items() if k.startswith("cq1_")) else "No"

            if st.form_submit_button("Continue ‚Üí"):
                st.session_state.user_data["answers1"] = answers1
                st.session_state.cq1_done = True
                st.rerun()

        # Back takes you up one step (category or free-text)
        if st.button("‚Üê Back"):
            st.session_state.page = (
                "symptom_primary_category_freeinput"
                if st.session_state.get("free_input_mode", False)
                else "symptom_subcategory"
            )
            st.rerun()
        return

    # 3Ô∏è‚É£ Stage 2: only if any CQ1 was ‚ÄúYes‚Äù
    answers1 = st.session_state.user_data.get("answers1", {})
    if any(v == "Yes" for v in answers1.values()):
        cq2s     = list(subset["Clarifying Questions2"].dropna().unique())
        answers2 = {}
        with st.form("cq2_form"):
            for j, q in enumerate(cq2s, 1):
                ans = st.radio(q, ["Yes", "No"], key=f"cq2_{j}")
                answers2[q] = ans
                answers2[f"cq2_{j}"] = ans   # NEW: store numbered key
            # summary flag for the whole stage
            answers2["cq2"] = "Yes" if any(v == "Yes" for k, v in answers2.items() if k.startswith("cq2_")) else "No"

            if st.form_submit_button("Continue ‚Üí"):
                merged = {**answers1, **answers2}
                st.session_state.user_data["clarifying_answers"] = merged
                st.session_state.page = "risk_flag_selection"
                del st.session_state.cq1_done
                st.rerun()

        # Back goes back into Stage 1
        if st.button("‚Üê Back"):
            del st.session_state.cq1_done
            st.rerun()
        return

    # 4Ô∏è‚É£ No ‚ÄúYes‚Äù in CQ1: skip straight to risk flags
    st.session_state.user_data["clarifying_answers"] = answers1
    del st.session_state.cq1_done
    st.session_state.page = "risk_flag_selection"
    st.rerun()

def risk_flag_selection_page():
    st.image(logo, width=80)
    st.subheader("These factors can affect your care. Select any that apply, or ‚ÄúNone.‚Äù")

    # ‚îÄ‚îÄ 1) Build the subset of candidate conditions ‚îÄ‚îÄ
    cat    = st.session_state.user_data.get("primary_category")
    sub    = st.session_state.user_data.get("subcategory")
    source = (
        st.session_state.matched_conditions
        if st.session_state.get("free_input_mode", False)
        else db
    )
    subset = source[
        (source["Primary Category"] == cat) &
        (source["SubCategory"]      == sub)
    ]
    if subset.empty:
        st.error("No conditions found here‚Äîplease start over.")
        return
    
    # 3Ô∏è‚É£ Prefer rows whose Labeling Rule passes for this user
    subset = subset.copy()

    def _passes(row):
        return evaluate_rule(row.get("Labeling Rule", ""), row, st.session_state.user_data)

    subset["rule_ok"] = subset.apply(_passes, axis=1)
    candidates = subset[subset["rule_ok"]]
    if not candidates.empty:
        subset = candidates
    

    # ‚îÄ‚îÄ 2) Map CQ2 ‚ÄúYes‚Äù answers back to rows ‚îÄ‚îÄ
    answers = st.session_state.user_data.get("clarifying_answers", {})
    flagged = []
    for idx, row in subset.iterrows():
        q2 = row["Clarifying Questions2"]
        if pd.notna(q2) and answers.get(q2) == "Yes":
            flagged.append(idx)

    # ‚îÄ‚îÄ 3) Triaging logic, always run ‚îÄ‚îÄ
    if len(flagged) == 1:
        chosen_idx = flagged[0]
    elif len(flagged) > 1:
        df_flagged = subset.loc[flagged].copy()
        df_flagged["Acuity Level"] = df_flagged["Acuity Level"].astype(int)
        chosen_idx = df_flagged["Acuity Level"].idxmax()
    else:
        subset["Acuity Level"] = subset["Acuity Level"].astype(int)
        chosen_idx = subset["Acuity Level"].idxmax()

    # ‚îÄ‚îÄ 4) Save the final condition ‚îÄ‚îÄ
    st.session_state.current_condition = subset.loc[chosen_idx]

    # ‚îÄ‚îÄ 5) Render its RiskFlags ‚îÄ‚îÄ
    cond = st.session_state.current_condition
    raw = str(cond.get("RiskFlags", "") or "")
    flags = [f.strip() for f in raw.split(",") if f.strip()]

    selected = []
    for flag in flags:
        if st.checkbox(flag, key=f"rf_{flag}"):
            selected.append(flag)

    none = st.checkbox("None / Not Applicable", key="rf_none")
    if none and selected:
        st.warning("‚ÄúNone‚Äù cannot be combined with other selections; only ‚ÄúNone‚Äù will be used.")

    # ‚îÄ‚îÄ 6) Continue ‚Üí record and go to Results ‚îÄ‚îÄ
    if st.button("Continue"):
        st.session_state.user_data["confirmed_risks"] = [] if none else selected
        st.session_state.page = "results"
        st.rerun()

    # ‚Üê Back ‚Üí clarifiers
    if st.button("‚Üê Back"):
        st.session_state.page = "clarifying_questions"
        st.rerun()



import re

def evaluate_rule(rule_str: str, condition: dict, user_data: dict) -> bool:
    """
    Evaluate Labeling Rule against the **user's** inputs:
      - symptom == X         ‚Üí user selected symptom X
      - risk_flag == Y       ‚Üí user ticked risk flag Y
      - cq1 == yes / cq2 == yes
    Supports AND/OR and parentheses.
    """
    import re

    # --- collect user facts ---
    sel_syms = {s.strip().lower() for s in user_data.get("selected_symptoms", []) if isinstance(s, str)}
    sel_rfs  = {r.strip().lower() for r in user_data.get("confirmed_risks", []) if isinstance(r, str)}
    answers  = {str(k).lower(): str(v).strip().lower()
                for k, v in user_data.get("clarifying_answers", {}).items()}

    # derive summary flags "cq1"/"cq2" = yes if ANY in that stage is yes
    cq1_any = any((k.startswith("cq1_") and v == "yes") for k, v in answers.items())
    cq2_any = any((k.startswith("cq2_") and v == "yes") for k, v in answers.items())
    answers["cq1"] = "yes" if cq1_any else "no"
    answers["cq2"] = "yes" if cq2_any else "no"

    def eval_atom(atom: str) -> bool:
        atom = atom.strip()

        # symptom == X (match normalized; allow exact or case-insensitive)
        m = re.match(r"^symptom\s*==\s*(.+)$", atom, re.IGNORECASE)
        if m:
            v = m.group(1).strip().lower()
            return v in sel_syms

        # risk_flag == Y
        m = re.match(r"^risk_flag\s*==\s*(.+)$", atom, re.IGNORECASE)
        if m:
            v = m.group(1).strip().lower()
            return v in sel_rfs

        # cqN == yes  (true if any question in that stage was Yes, or explicit key present)
        m = re.match(r"^cq(\d+)\s*==\s*yes$", atom, re.IGNORECASE)
        if m:
            n = m.group(1)             # "1" or "2"
            # accept either summary key cq1/cq2 or any numbered cq1_*, cq2_*
            if answers.get(f"cq{n}", "") == "yes":
                return True
            return any(k.startswith(f"cq{n}_") and v == "yes" for k, v in answers.items())

        return False  # unknown atom

    # Tokenize and build boolean expression
    parts = re.split(r"(\bAND\b|\bOR\b|\(|\))", str(rule_str or ""), flags=re.IGNORECASE)
    expr = ""
    for p in parts:
        t = p.strip()
        if not t:
            continue
        if re.fullmatch(r"AND", t, re.IGNORECASE):
            expr += " and "
        elif re.fullmatch(r"OR", t, re.IGNORECASE):
            expr += " or "
        elif t in ("(", ")"):
            expr += t
        else:
            expr += str(eval_atom(t))

    try:
        return bool(eval(expr)) if expr else False
    except Exception:
        return False


def make_recommendation(condition: dict, user_flags: dict, risk_flags: list) -> str:
    # Determine escalation
    acuity = condition.get("Acuity Level", 0)
    is_esc = bool(risk_flags) or (acuity == 3)

    # Confidence guard
    conf = condition.get("Labeling Confidence", "Low")
    if conf == "Low":
        return ""

    # Rule match guard (allow escalation)
    rule_ok = evaluate_rule(
                    condition["Labeling Rule"],
                    condition,
                    st.session_state.user_data
    )

    # ‚¨Ö NEW: enforce rule before building recommendation
    if not rule_ok and not is_esc:
        return ""

    # Certainty phrase
    certainty = "very likely" if conf == "High" else "symptoms suggest"

    # Pick templates
    if is_esc:
        base_tmpl = condition.get("Escalated Narrative Template (Risk Flags Present)", "")
        rec_text = condition.get("Escalated Recommendation", "")
    else:
        base_tmpl = condition.get("Default Narrative Template", "")
        rec_text = condition.get("Default Recommendation", "")

    # Render base with placeholders
    base = base_tmpl.format(
        certainty=certainty,
        risk_flags=", ".join(risk_flags),
        default_rec=condition.get("Default Recommendation", ""),
        escalated_rec=condition.get("Escalated Recommendation", "")
    )

    # Build recommendation without duplication
    if ('{default_rec}' in base_tmpl) or ('{escalated_rec}' in base_tmpl):
        recommendation = base
    else:
        recommendation = f"{base} {rec_text}".strip()

     #Append emergency note marker
    note = condition.get("Emergency Narrative (If Applicable)", "").strip()
    if note:
        recommendation += f"\n\nüö® Important: {note}"

    return recommendation


def results_page():
    # Header and Title
    st.image(logo, width=80)
    #st.header("Based on your answers, your likely condition is:")

    # Fetch the chosen condition
    condition = st.session_state.current_condition
    if condition is None:
        st.error("No condition selected. Please start over.")
        if st.button("üîÑ Start New Check"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # Show the condition's name
    #condition_title = condition.get("Condition", "")
    #st.subheader(condition_title)

    # Determine baseline acuity (for card color)
    if st.session_state.get("free_input_mode"):
        baseline_rank = int(st.session_state.matched_conditions.get("Acuity Level", 0).max())
    else:
        baseline_rank = int(condition.get("Acuity Level", 0) or 0)

    # Gather & sanitize risk flags (avoid accidental truthy [""])
    raw_flags  = st.session_state.user_data.get("confirmed_risks", [])
    risk_flags = [rf.strip() for rf in raw_flags if isinstance(rf, str) and rf.strip()]

    # ‚Äî‚Äî‚Äî Assemble user_flags with normalized keys ‚Äî‚Äî‚Äî
    user_data  = st.session_state.user_data
    user_flags = {}

    # 1) Symptoms from selected_symptom
    for sym in user_data.get("selected_symptoms", []):
        key = sym.strip().lower().replace(" ", "_")
        user_flags[key] = True

    # 2) Clarifiers from clarifying_answers
    for question, ans in user_data.get("clarifying_answers", {}).items():
        if ans == "Yes":
            key = question.strip().lower().replace(" ", "_")
            user_flags[key] = True

    # 3) Risk flags
    for rf in risk_flags:
        key = rf.strip().lower().replace(" ", "_")
        user_flags[key] = True

    # Generate recommendation (string may include an appended emergency line in older builds)
    recommendation = make_recommendation(condition, user_flags, risk_flags)

    if recommendation:
        # ‚úÖ Only show headline when recommendation exists
        st.header("Based on your answers, your likely condition is:")

        # ‚¨áÔ∏è Move these two lines here
        condition_title = condition.get("Condition", "")
        st.subheader(condition_title)
    
    else:
        html = """
        <div style="
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            border-radius: 12px;
            padding: 24px;
            font-size: 1.25rem;
            line-height: 1.6;
            color: #3a2e00;
            font-weight: 500;
            text-align: center;
        ">
            I couldn‚Äôt make a confident match for your symptoms.<br>
            That happens sometimes, and it simply means a human touch is needed.<br>
            <strong>Consider reaching out to a healthcare professional ‚Äî or you can try another check with more details.</strong>
        </div>
        """
        st.markdown(html, unsafe_allow_html=True)

        # Add space before buttons
        st.markdown("<div style='margin-top: 20px;'></div>", unsafe_allow_html=True)

        col1, col2 = st.columns(2)
        with col1:
            if st.button("üîÑ Start Over", use_container_width=True):
                st.session_state.clear()
                st.session_state.page = "welcome"
                st.rerun()
        with col2:
            if st.button("üìÖ Schedule an Appointment", use_container_width=True):
                st.info("Appointment scheduling flow will be implemented here.")
        return

    # Display recommendation or fallback with styled blocks
    if recommendation:
        # Your escalation rule for card color:
        is_esc = (baseline_rank == 3) or bool(risk_flags)
        block_class = "report-block" if is_esc else "report-block report-block--ok"

        # If the recommendation string contains an appended emergency line,
        # strip it from the main text to avoid duplication (we render emergency separately).
        parts = recommendation.split('\n\nüö® Important: ')
        main_text = parts[0].strip()

        # MAIN CARD (mobile-friendly class)
        safe_text = main_text.replace('\n', '<br>')
        html = (
            f"<div class='{block_class}'style='font-size: 1.2rem;'>"
            f"{main_text.replace('\n','<br>')}"
            "</div>"
        )

        # Optional referral line below the card
        ref_text = (condition.get("Referral", "") or "").strip()
        if ref_text:
             html += f"<div style='margin-top:20px; font-size:1.2rem;'> ü©∫ <strong>{ref_text}</strong></div>"

        st.markdown(html, unsafe_allow_html=True)

        # EMERGENCY NOTE ‚Äî render once, as a separate block
        emergency = (condition.get("Emergency Narrative (If Applicable)", "") or "").strip()
        if emergency:
            st.markdown(
                f"<div class='emergency-block' style='font-size: 1.2rem; margin-bottom: 20px;' >üö® Important: {emergency}</div>",
                unsafe_allow_html=True
            )

    else:
        # Fallback amber (mobile-friendly)
        html = (
            "<div class='report-block report-block--warn'>"
            "I‚Äôm not able to match a condition confidently. Please consider consulting a "
            "healthcare professional for a definitive evaluation."
            "</div>"
        )
        st.markdown(html, unsafe_allow_html=True)

    # Optional: Schedule Appointment button
    if condition.get("Referral") and st.button("üìÖ Schedule an Appointment"):
        st.info("Appointment scheduling will be available soon.")

    # Download report & New Check buttons (single set; CSS centers on mobile only)
    col1, col2 = st.columns([1, 1])

    with col1:
        report_text = generate_report()
        st.download_button(
            label="üìÑ Download Full Report",
            data=report_text,
            file_name=f"{condition_title}_report.txt",
            key="dl_report"
        )

    with col2:
        if st.button("üîÑ Start New Check", key="newcheck"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()

   # ‚¨áÔ∏è CSS comes immediately after these buttons
    st.markdown("""
    <style>
    @media (max-width: 640px) {
      /* Center the download button itself */
      div[data-testid="stDownloadButton"] > button {
        display: block !important;
        margin-left: auto !important;
        margin-right: auto !important;
      }
    }
    </style>
    """, unsafe_allow_html=True)



def fallback_page():
    st.image(logo, width=80)
    st.warning("I couldn‚Äôt find a clear match for your symptoms, which could mean they‚Äôre mild or need professional evaluation.")
    st.markdown("**Would you like to speak with a Doctor about this?**")
    col1, col2, col3 = st.columns([1,1,1])
    with col1:
        if st.button("üìÖ Schedule an Appointment"):
            st.info("Appointment scheduling flow will be implemented here.")
    with col2:
        if st.button("üîÑ Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
    with col3:
        if st.button("‚Üê Back"):
            st.session_state.page = "clarifying_questions"
            st.rerun()

PAGES = {
    "welcome": welcome_page,
    "user_info": user_info_page,
    "symptom_category": symptom_category_page,
    "symptom_free_input": symptom_free_input_page,
    "symptom_primary_category_freeinput": symptom_primary_category_freeinput_page,
    "symptom_subcategory": symptom_subcategory_page,
    "symptom_selection": symptom_selection_page,
    "clarifying_questions": clarifying_questions_page,
    "risk_flag_selection": risk_flag_selection_page,
    "results": results_page,
    "fallback_page": fallback_page,
    "analytics": analytics_page,
}
# ---- Auth gate: show login until authenticated ----
if not st.session_state.get("logged_in", False):
    login_page()
    st.stop()

PAGES[st.session_state.page]()