# -*- coding: utf-8 -*-
"""App_v5.5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E0X9U1nI-2YPh5tNkrh-K8g3lFZhDf9L
"""

import streamlit as st
import pandas as pd
from PIL import Image
import re
from difflib import SequenceMatcher
import os
import csv
from datetime import datetime
import html



LOG_PATH = "failure_log.csv"

GENERIC_TOKENS = {"pain", "ache", "aches", "soreness", "discomfort",
                  "rash", "rashes", "fever", "cough", "vomiting",
                  "diarrhea", "dizziness", "fatigue", "weakness"}

# New: treat â€œtendernessâ€ as a generic synonym so â€œbreast painâ€ â‰ˆ â€œbreast tendernessâ€
GENERIC_SYNONYMS = {"pain", "ache", "aches", "soreness", "discomfort", "tenderness",
                    "rash", "rashes", "fever", "cough", "vomiting",
                    "diarrhea", "dizziness", "fatigue", "weakness"}

GENERIC_SYNONYMS |= {"hives","urticaria","exanthem","dermatitis","eruption","itch","itchy","itching","pruritus"}

# Map each generic to common synonyms seen in the DB
GENERIC_FAMILY = {
    "pain": {"pain","ache","aches","soreness","discomfort","tenderness"},
    "rash": {"rash","rashes","hives","urticaria","exanthem","dermatitis","eruption"},
    "fever": {"fever","pyrexia","temperature"},
    "cough": {"cough","coughing"},
    "vomiting": {"vomiting","vomit","emesis","throwing","throwing up"},
    "diarrhea": {"diarrhea","diarrhoea","loose","watery","stools","stool"},
    "dizziness": {"dizziness","vertigo","lightheadedness"},
    "fatigue": {"fatigue","tiredness","malaise"},
    "weakness": {"weakness","asthenia"},
}

WEAK_ANCHORS = {"skin", "body", "area", "surface"}

def log_failure(record: dict):
    file_exists = os.path.isfile(LOG_PATH)
    with open(LOG_PATH, "a", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=list(record.keys()))
        if not file_exists:
            writer.writeheader()
        writer.writerow(record)

def analytics_page():
    st.header("ğŸ“Š App Failure Report")
    if not os.path.isfile(LOG_PATH):
        st.info("No failures logged yet.")
        return

    df = pd.read_csv(LOG_PATH, parse_dates=["timestamp"])
    st.subheader("Recent Failures")
    st.dataframe(df.sort_values("timestamp", ascending=False).head(20))

    st.subheader("Failures by Reason")
    counts = df["reason"].value_counts().reset_index()
    counts.columns = ["Reason","Count"]
    st.table(counts)

def stem(word: str) -> str:
    w = word.lower().strip()
    for suf in ("ing", "ion", "ed", "s", "ness", "able"):
        if w.endswith(suf):
            return w[: -len(suf)]
    return w

st.set_page_config(page_title="LEXY... LexMedical AI Triage System", page_icon="ğŸ©º", layout="centered")

# --- Mobile-friendly, high-contrast styles ---
st.markdown("""
<style>
.report-block {
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 10px;
  padding: 16px;
  font-size: 1rem;
  line-height: 1.6;
  color: #2b0000;
  word-wrap: break-word;
  overflow-wrap: anywhere;
}
.report-block--ok {
  background-color: #d4edda;
  border-color: #c3e6cb;
  color: #062b0a;
}            
.report-block--warn {
  background-color: #fff3cd;
  border: 1px solid #ffeeba;
  color: #3a2e00;
}
.emergency-block {
  margin-top: 16px;
  padding: 14px;
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 10px;
  font-weight: 600;
  font-size: 1rem;
  line-height: 1.6;
  color: #2b0000;
  word-wrap: break-word;
  overflow-wrap: anywhere;
}
@media (max-width: 640px) {
  .report-block, .emergency-block {
    font-size: 1.05rem;
    line-height: 1.7;
    padding: 18px;
  }
  .stButton > button { width: 100% !important; }
}
</style>
""", unsafe_allow_html=True)

# Initialize session state safely
if 'free_input_mode' not in st.session_state:
    st.session_state.free_input_mode = False
if 'page' not in st.session_state:
    st.session_state.page = "welcome"
if 'user_data' not in st.session_state:
    st.session_state.user_data = {}
if 'current_condition' not in st.session_state:
    st.session_state.current_condition = None
if 'confirmed_risks' not in st.session_state:
    st.session_state.confirmed_risks = []
if 'matched_conditions' not in st.session_state:
    st.session_state.matched_conditions = pd.DataFrame()
if 'logged_in' not in st.session_state:
    st.session_state.logged_in = False

@st.cache_data
def load_data():
    df = pd.read_excel("SymptomBotDB.xlsx")
    # â”€â”€ Normalize every header: remove leading/trailing whitespace â”€â”€
    df.columns = df.columns.str.strip()
    return df
# --- Free-text normalization driven by Excel (FreeTextMap sheet) ---

@st.cache_data
def load_freetext_map() -> dict:
    """
    Reads SymptomBotDB.xlsx -> sheet 'FreeTextMap' with columns:
      from_phrase, to_phrase  (case-insensitive)
    Returns dict {from_phrase_lower: to_phrase_lower}.
    If the sheet is missing, returns {} (no-op).
    """
    try:
        df_map = pd.read_excel("SymptomBotDB.xlsx", sheet_name="FreeTextMap")
        df_map.columns = df_map.columns.str.strip().str.lower()
        if not {"from_phrase","to_phrase"}.issubset(df_map.columns):
            return {}
        # build lowercase map, drop blanks
        m = {}
        for _, r in df_map.iterrows():
            fp = str(r["from_phrase"]).strip().lower()
            tp = str(r["to_phrase"]).strip().lower()
            if fp and tp and fp != "nan" and tp != "nan":
                m[fp] = tp
        return m
    except Exception:
        return {}

FT_MAP = load_freetext_map()

# c) fuzzy-stem match across token pairs (safer)
def ok_pair(us, ds):
    # ignore very short tokens for fuzzy; exact/substring already handled earlier
    if len(us) < 4 or len(ds) < 4:
        return False
    # require same starting letter OR substring relation to avoid heartâ‰ˆear/hurt
    if not (us[0] == ds[0] or us in ds or ds in us):
        return False
    return SequenceMatcher(None, us, ds).ratio() >= 0.80  # was 0.65


def normalize_free_text(raw: str) -> str:
    """
    Minimal, safe normalization:
      - lowercase + trim
      - unify curly quotes
      - apply FreeTextMap replacements (longest-first)
      - a couple high-impact typo/alias fixes
    Returns a SINGLE normalized string you feed into your existing matcher.
    """
    if not raw:
        return ""
    text = raw.strip().lower()

    # normalize curly quotes to ascii to avoid miss matches
    text = (text
            .replace("â€™", "'")
            .replace("â€˜", "'")
            .replace("â€œ", '"')
            .replace("â€", '"'))

    # tiny typo fix that bites often
    text = text.replace("heatbeat", "heartbeat")

    # Apply Excel-driven phrase replacements, longest keys first to avoid partial shadowing
    if FT_MAP:
        for k in sorted(FT_MAP.keys(), key=len, reverse=True):
            if k in text:
                text = text.replace(k, FT_MAP[k])
    
    text = apply_stop_phrases(text)
    return text

# Misleading phrases that shouldn't trigger body-part detection
STOP_PHRASES = {
    "side effects": "side_effects",  # neutralize "side" so it won't map to flank
}

def apply_stop_phrases(text: str) -> str:
    """Replace misleading phrases with inert tokens AFTER normalization."""
    t = text or ""
    for bad, safe in STOP_PHRASES.items():
        t = t.replace(bad, safe)
    return t


def load_logo():
    return Image.open("logo.png")

db = load_data()
logo = load_logo()

# ===== Body-part synonyms â†’ category hints (resolved to DB labels) =====

def _cat_norm(s: str) -> str:
    """Canonicalize for matching category names (lowercase, strip, normalize quotes)."""
    return str(s).strip().lower().replace("â€™", "'").replace("â€˜", "'")

# Build map of canonicalâ†’exact label from the DB (so hints always resolve to real labels)
CAT_CANON = {}
for c in db["Primary Category"].dropna().astype(str).unique():
    key = _cat_norm(c)
    # First one wins; we want the exact label as it appears in the DB
    CAT_CANON.setdefault(key, c)

# Tight, human-curated body-part aliases with intended category hints.
# âš ï¸ Hints are written using the **exact** strings from your DB above.
BODY_PART_SYNONYMS = {
    # Head & neck
    "head":         {"aliases": {"head", "skull"}, "category_hints": ["Gen. Body Pain or Discomfort", "Injury and Bites"]},
    "face":         {"aliases": {"face","facial","cheek","cheeks","jaw","jawbone","chin"}, "category_hints": ["Ear, Nose and Throat","Dental","Skin or Rashes","Eye Irritation"]},
    "scalp":        {"aliases": {"scalp"}, "category_hints": ["Skin or Rashes"]},
    "eye":          {"aliases": {"eye","eyes","eyelid","eyelids"}, "category_hints": ["Eye Irritation"]},
    "ear":          {"aliases": {"ear","ears"}, "category_hints": ["Ear, Nose and Throat"]},
    "nose":         {"aliases": {"nose","nostril","nostrils"}, "category_hints": ["Ear, Nose and Throat","Breathing or Cough"]},
    "throat":       {"aliases": {"throat","tonsil","tonsils"}, "category_hints": ["Ear, Nose and Throat","Breathing or Cough"]},
    "mouth_teeth":  {"aliases": {"mouth","gum","gums","tooth","teeth","tongue","lip","lips"}, "category_hints": ["Dental","Ear, Nose and Throat"]},
    "neck":         {"aliases": {"neck","nape"}, "category_hints": ["Gen. Body Pain or Discomfort","Swelling"]},

    # Chest, back, abdomen
    "chest":        {"aliases": {"chest","rib","ribs"}, "category_hints": ["Breathing or Cough","Gen. Body Pain or Discomfort","Emergency"]},
    "breast":       {"aliases": {"breast","breasts","nipple","nipples","areola"}, "category_hints": ["Womenâ€™s Health","Swelling"]},
    "back":         {"aliases": {"back","upper back","lower back","waist"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "abdomen":      {"aliases": {"abdomen","abdominal","belly","tummy","stomach","tommy"}, "category_hints": ["Stomach & Digestion"]},
    "flank_side":   {"aliases": {"flank","side"}, "category_hints": ["Thirst & Urination","Stomach & Digestion"]},
    "hip":          {"aliases": {"hip","hips"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "groin":        {"aliases": {"groin","crotch"}, "category_hints": ["Urinary & Sexual Health","Menâ€™s Health","Womenâ€™s Health"]},

    # Buttocks & anorectal
    "buttocks":     {"aliases": {"buttocks","butt","bum","backside","behind","ass"}, "category_hints": ["Rectal & Bowel Health","Skin or Rashes"]},
    "anus_rectum":  {"aliases": {"anus","anal","rectum","rectal"}, "category_hints": ["Rectal & Bowel Health"]},

    # Upper limbs
    "shoulder":     {"aliases": {"shoulder","shoulders","collarbone","clavicle"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "arm":          {"aliases": {"arm","arms"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites","Swelling"]},
    "elbow":        {"aliases": {"elbow","elbows"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "forearm":      {"aliases": {"forearm","forearms"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "wrist":        {"aliases": {"wrist","wrists"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "hand":         {"aliases": {"hand","hands","palm","finger","fingers","thumb","thumbs"}, "category_hints": ["Gen. Body Pain or Discomfort","Skin or Rashes","Injury and Bites"]},

    # Lower limbs
    "leg":          {"aliases": {"leg","legs"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites","Swelling"]},
    "thigh":        {"aliases": {"thigh","thighs","lap"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "knee":         {"aliases": {"knee","knees"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites","Swelling"]},
    "calf":         {"aliases": {"calf","calves"}, "category_hints": ["Gen. Body Pain or Discomfort","Swelling"]},
    "shin":         {"aliases": {"shin","shins"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites"]},
    "ankle":        {"aliases": {"ankle","ankles"}, "category_hints": ["Gen. Body Pain or Discomfort","Injury and Bites","Swelling"]},
    "foot":         {"aliases": {"foot","feet","heel","heels","sole","toes","toe"}, "category_hints": ["Gen. Body Pain or Discomfort","Skin or Rashes","Injury and Bites","Swelling"]},

    # Genitals (gender gating happens later)
    "male_genitals":   {"aliases": {"penis","testicle","testicles","scrotum","balls","manhood","dick"}, "category_hints": ["Menâ€™s Health","Urinary & Sexual Health"]},
    "female_genitals": {"aliases": {"vagina","vaginal","vulva","labia","clitoris","womanhood","private part"}, "category_hints": ["Womenâ€™s Health","Urinary & Sexual Health"]},

    # Skin (general)
    "skin":         {"aliases": {"skin"}, "category_hints": ["Skin or Rashes"]},
}

# Resolve every hint to the exact DB label; drop/flag any that donâ€™t resolve
BP_ALIAS_TO_HINTS = {}
_BAD_HINTS = []  # if any, fix the spelling/spacing in BODY_PART_SYNONYMS

for _canon, data in BODY_PART_SYNONYMS.items():
    for alias in data["aliases"]:
        resolved = set()
        for hint in data["category_hints"]:
            key = _cat_norm(hint)
            real = CAT_CANON.get(key)
            if real is None:
                _BAD_HINTS.append((alias, hint))
            else:
                resolved.add(real)
        if resolved:
            BP_ALIAS_TO_HINTS[alias.lower()] = resolved

# Optional: print unresolved hints to Streamlit sidebar (visible only to admins/devs)
if _BAD_HINTS:
    st.sidebar.warning("Unrecognized category_hints in BODY_PART_SYNONYMS (check spelling):")
    for alias, hint in _BAD_HINTS:
        st.sidebar.write(f"alias='{alias}'  hint='{hint}'  â†’ NOT IN DB")
# ===== End body-part hints =====


# --- UTILITY FUNCTIONS ---


def is_gender_allowed(primary_category, gender, suppress_error=False):
    primary_category = primary_category.replace("â€™", "'")
    WOMEN_SPECIFIC = {
        "Women's Health", "Pelvic Inflammatory Disease", "Breast Lump",
        "Cervical Cancer", "Menopause", "Fibroids", "Heavy Menstrual Bleeding",
        "Yeast Infection", "Bacterial Vaginosis", "Endometriosis", "PCOS",
        "Pelvic Organ Prolapse", "Ovarian Cyst", "Ectopic Pregnancy"
    }
    MEN_SPECIFIC = {
        "Men's Health", "Prostatitis", "Testicular Torsion",
        "Benign Prostatic Hyperplasia", "Varicocele", "Balanitis"
    }
    if gender == "Male" and primary_category in WOMEN_SPECIFIC:
        if not suppress_error:
            st.error("This category is not available for your selected gender")
        return False
    if gender == "Female" and primary_category in MEN_SPECIFIC:
        if not suppress_error:
            st.error("This category is not available for your selected gender")
        return False
    return True

def display_grid(items, cols=3):
    rows = [items[i:i + cols] for i in range(0, len(items), cols)]
    for row in rows:
        columns = st.columns(len(row))
        for col, item in zip(columns, row):
            with col:
                if st.button(item, use_container_width=True):
                    return item
    return None

def generate_report():
    condition = st.session_state.current_condition
    user = st.session_state.user_data
    report = f"""
LEXAI SYMPTOM CHECKER REPORT
============================

Patient Details:
- Age: {user.get('age', 'N/A')}
- Gender: {user.get('gender', 'N/A')}

Assessment:
- Likely Condition: {condition['Condition'] if condition is not None else 'N/A'}
- Risk Factors: {', '.join(st.session_state.confirmed_risks) if st.session_state.confirmed_risks else 'None'}

Recommendation:
{condition['Escalated Recommendation' if st.session_state.get('is_high_risk') else 'Default Recommendation'] if condition is not None else ''}
"""
    return report

def similarity(a, b):
    return SequenceMatcher(None, a, b).ratio()

def match_conditions_by_symptoms(input_text, db):
    input_symptoms = [sym.strip().lower() for sym in input_text.split(",") if sym.strip()]
    matched_conditions = []
    for _, row in db.iterrows():
        db_symptoms = [sym.lower().strip() for sym in str(row["Symptoms"]).split(",") if sym.strip()]
        for user_sym in input_symptoms:
            for db_sym in db_symptoms:
                if user_sym in db_sym or db_sym in user_sym or similarity(user_sym, db_sym) >= 0.65:
                    matched_conditions.append(row)
                    break
            else:
                continue
            break
    return pd.DataFrame(matched_conditions).drop_duplicates()

def login_page():
    st.title("Lexy- Carekonnect Symptom Checker Login")

    # Create a form for login
    with st.form("login_form"):
        password = st.text_input("Enter Password", type="password")
        submit_button = st.form_submit_button("Login")

    # Check password
    if submit_button:
        if password == "lexmedical":
            st.session_state.logged_in = True
            st.session_state.page = "welcome"
            st.rerun()
        else:
            st.error("Incorrect password. Please try again.")




def welcome_page():
    # â”€â”€â”€ 1) Inject custom CSS for styling â”€â”€â”€
    st.markdown("""
    <style>
      /* Center and size the logo container */
      .logo-container {
        text-align: center;
        margin-bottom: 1.5rem;
      }
      /* Title styling */
      .welcome-title {
        text-align: center;
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 1rem;
      }
      /* Body text styling */
      .welcome-text {
        max-width: 600px;
        margin: 0 auto 2rem auto;
        font-size: 1.1rem;
        line-height: 1.6;
        color: #444;
      }
      /* Button sizing and coloring */
      .stButton > button {
        width: 220px;
        height: 50px;
        font-size: 1.1rem;
        border-radius: 8px;
        border: none;
        margin-top: 1rem;
      }
      .stButton > button[disabled] {
        background-color: #bbb !important;
        color: #fff !important;
        cursor: not-allowed;
      }
      .stButton > button:not([disabled]) {
        background-color: #e63946 !important;
        color: #fff !important;
      }
      /* Footer styling */
      .footer {
        text-align: center;
        font-size: 0.9rem;
        color: #666;
        margin-top: 3rem;
      }
    </style>
    """, unsafe_allow_html=True)

    # â”€â”€â”€ 2) Logo â”€â”€â”€
    st.markdown("<div class='logo-container'>", unsafe_allow_html=True)
    st.image(logo, width=120)
    st.markdown("</div>", unsafe_allow_html=True)

    # â”€â”€â”€ 3) Welcome text â”€â”€â”€
    st.markdown("<div class='welcome-title'>Lexy- AI Based Symptom Checker</div>", unsafe_allow_html=True)
    st.markdown("""
      <div class='welcome-text'>
         <strong>Hi ğŸ‘‹, Iâ€™m Lexy â€” here to help you make sense of your symptoms and feel more in control of your health.</strong><br><br>
        Lexy is an AI Triage tool that helps users better understand their symptoms and suggests next stepsâ€”whether thatâ€™s self-care, seeing a provider, or seeking urgent help.<br>
        It does not offer medical diagnoses and is not a substitute for care from a qualified health professional.<br><br>
        This tool is not recommended for children under 16, pregnant individuals, or those with multiple health conditions.<br><br>
        <strong>In case of emergency</strong>â€”such as chest pain, severe bleeding, or difficulty breathingâ€”please call emergency services or go to the nearest hospital.
      </div>
    """, unsafe_allow_html=True)

    # â”€â”€â”€ 4) Confirmation checkbox â”€â”€â”€
    confirm = st.checkbox("I have read and understood the above")

    # â”€â”€â”€ 5) Centered Start button, gated by checkbox â”€â”€â”€
    _, center, _ = st.columns([1,2,1])
    with center:
        if st.button("Start Symptom Check", disabled=not confirm):
            st.session_state.page = "user_info"
            st.rerun()

    # â”€â”€â”€ 6) Footer â”€â”€â”€
    st.markdown("<div class='footer'>Powered by LexMedical Services LTD</div>", unsafe_allow_html=True)

    # â”€â”€ Hidden Admin Access (testing only) â”€â”€
    pwd = st.sidebar.text_input("Dev code", type="password")
    if pwd == "Akinola":  # â† replace with your own secret
        if st.sidebar.button("View Analytics"):
            st.session_state.page = "analytics"
            st.rerun()

def user_info_page():
    st.image(logo, width=80)
    st.subheader("Before we begin, Iâ€™d like to know a little about you.")

    with st.form("user_info_form"):
        age = st.number_input("Age", min_value=0, max_value=120)
        # â†â€” THIS IS THE NEW â€œPediatric Modeâ€ NOTE
        if 0 <= age <= 14:
            st.info("ğŸ‘¶ Ages 0â€Šâ€“â€Š14 will activate Pediatric mode on the next screen.")

        gender = st.radio("Gender", ["Male", "Female"], horizontal=True)
        conditions = st.text_input(
            "Existing conditions",
            placeholder="Mention any long-term health issues you live with (like asthma or none)"
        )

        submit_col, _ = st.columns([1, 2])
        with submit_col:
            cont = st.form_submit_button("Continue â†’", type="primary")

    back_col, _ = st.columns([1, 2])
    with back_col:
        back = st.button("â† Back")

    if back:
        st.session_state.page = "welcome"
        st.rerun()
    if cont:
        # â”€â”€ Save demographics â”€â”€
        st.session_state.user_data['age']        = age
        st.session_state.user_data['gender']     = gender
        st.session_state.user_data['conditions'] = conditions

        # â”€â”€ 1) Pediatrics shortcut for ages 0â€“14 â”€â”€
        if 0 <= age <= 14:
            st.session_state.user_data['primary_category'] = "Pediatrics"
            st.session_state.page = "symptom_subcategory"
        else:
            # â”€â”€ Adult/other flow unchanged â”€â”€
            st.session_state.page = "symptom_category"

        st.rerun()

def symptom_category_page():
    # â”€â”€â”€ 0) Inject CSS for uniform, wrapped, full-width buttons â”€â”€â”€
    st.markdown(
        """<style>
          .stButton > button {
            width: 100% !important;
            white-space: normal !important;
            word-wrap: break-word !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            min-height: 4rem !important;
            padding: 0.75rem 1rem !important;
          }
        </style>""",
        unsafe_allow_html=True
    )

    # â”€â”€â”€ 1) Logo & heading â”€â”€â”€
    st.image(logo, width=80)
    st.subheader("Letâ€™s start with whatâ€™s bothering you today")

    # â”€â”€â”€ 2) Gender guard â”€â”€â”€
    current_gender = st.session_state.user_data.get('gender')
    if not current_gender:
        st.error("Gender not selected. Please go back.")
        return
    
    # â”€â”€â”€ 2b) Age-aware category list (hide Pediatrics for 15+) â”€â”€â”€
    current_age = st.session_state.user_data.get('age')

    valid_categories = []
    for cat in db["Primary Category"].unique():

        # Hide Pediatrics for ages 15+
        if (current_age is not None) and (current_age >= 15) and str(cat).strip().lower() == "pediatrics":
            continue
        if is_gender_allowed(cat, current_gender, suppress_error=True):
            valid_categories.append(cat)

   
    # â”€â”€â”€ 3) Render your 3-col grid via display_grid â”€â”€â”€
    selected = display_grid(valid_categories, cols=3)

    # â”€â”€â”€ 4) Handle a valid selection â”€â”€â”€
    if selected and is_gender_allowed(selected, current_gender):
        st.session_state.free_input_mode = False
        st.session_state.matched_conditions = pd.DataFrame()
        st.session_state.user_data['primary_category'] = selected
        st.session_state.page = "symptom_subcategory"
        st.rerun()

    # â”€â”€â”€ 5) Free-text fallback â”€â”€â”€
    if st.button("Canâ€™t find your symptoms? Enter them here"):
        st.session_state.page = "symptom_free_input"
        st.rerun()

    # â”€â”€â”€ 6) Back button â”€â”€â”€
    if st.button("â† Back"):
        st.session_state.page = "user_info"
        st.rerun()

def symptom_free_input_page():
    import re
    from collections import defaultdict
    import pandas as pd
    from datetime import datetime

    st.image(logo, width=80)
    st.subheader("What are your symptoms?")
    st.markdown("Use 1â€“2 simple symptoms. Separate multiple with commas (e.g., headache, fever, dizziness, leg pain)")

    # ---------- Local helpers (scoped to this function; safe to remove/move later) ----------
    def _ck_normalize(s: str) -> str:
        # keep commas/semicolons for phrase splits; letters/digits/spaces only
        return re.sub(r'\s+', ' ', re.sub(r'[^A-Za-z0-9\s,;]', ' ', str(s).lower())).strip()

    def _ck_tokenize(s: str):
        # tokens are words >=3 letters
        return re.findall(r"[A-Za-z]{3,}", str(s).lower())

    def _ck_stem(token: str) -> str:
        t = token.lower()
        # conservative suffix strip (single pass)
        for suff in ("ness", "ions", "ion", "ing", "ed", "es", "s"):
            if len(t) > 4 and t.endswith(suff):
                t = t[:-len(suff)]
                break
        # y -> i normalization (dizzy -> dizzi)
        if t.endswith("y") and len(t) >= 4:
            t = t[:-1] + "i"
        return t
    
    def _ck_detect_body_part_hints(free_text_norm: str):
        """Return a set of category labels hinted by body-part aliases in the input."""
        hints = set()
        s = f" {free_text_norm} "  # pad for simple phrase detection
        # phrase-level match (handles multi-word aliases like 'lower back')
        for alias, cats in BP_ALIAS_TO_HINTS.items():
            if f" {alias} " in s:
                hints |= cats
        # token-level match (single words)
        for tok in set(_ck_tokenize(free_text_norm)):
            cats = BP_ALIAS_TO_HINTS.get(tok, set())
            hints |= cats
        return hints



    # Minimal curated synonyms (can be expanded later; not exhaustive by design)
    _CK_SYNONYMS = {
        "rash": {"rashes", "hives", "urticaria", "dermatitis", "exanthem"},
        "dizziness": {"dizzy", "lightheaded"},
        "urinate": {"urinating", "urination"},
        "vomit": {"vomiting", "emesis"},
    }

    def _ck_variants(token: str):
        t = token.lower().strip()
        base = {t, _ck_stem(t)}
        infl = set()

        # add/remove simple inflections
        for suff in ("s", "es", "ed", "ing", "ion", "ions", "ness"):
            if t.endswith(suff) and len(t) > len(suff) + 2:
                infl.add(t[:-len(suff)])
            infl.add(t + suff)

        # y <-> i (dizzy -> dizzi)
        if t.endswith("y") and len(t) >= 4:
            infl.add(t[:-1] + "i")

        syn = _CK_SYNONYMS.get(t, set())

        out = base | infl | syn | {_ck_stem(x) for x in (infl | syn)}
        return {x for x in out if len(x) >= 3}

    def _ck_build_row_index(df, pri_col="Primary Category", sym_col="Symptoms"):
        rows = []
        for i, r in df.iterrows():
            cat = _ck_normalize(r.get(pri_col, ""))
            sym = _ck_normalize(r.get(sym_col, ""))
            cat_toks = set(_ck_tokenize(cat))
            sym_toks = set(_ck_tokenize(sym))
            rows.append({
                "idx": i,
                "cat": r.get(pri_col, ""),
                "sym": r.get(sym_col, ""),
                # include both raw token and stem for fast exact/stem checks
                "cat_tokens": set.union(cat_toks, {_ck_stem(t) for t in cat_toks}),
                "sym_tokens": set.union(sym_toks, {_ck_stem(t) for t in sym_toks}),
            })
        return rows

    def _ck_score_categories_and_subset(free_text, df, pri_col="Primary Category", sym_col="Symptoms"):
        # B2 â€“ part 1: split normalize & tokenize so we can reuse free_norm
        free_norm = _ck_normalize(free_text)
        free_norm = apply_stop_phrases(free_norm)

        tokens    = set(_ck_tokenize(free_norm))

        if not tokens:
            return [], df.iloc[0:0]

        # detect hinted categories from body-part aliases (needs _ck_detect_body_part_hints + BP_ALIAS_TO_HINTS)
        hint_boosts = _ck_detect_body_part_hints(free_norm)

        GENERIC_FLAT = set().union(*GENERIC_FAMILY.values())
        def _is_generic(tok: str) -> bool:
            return (tok in GENERIC_FLAT) or (_ck_stem(tok) in GENERIC_FLAT)
        non_generic = {t for t in tokens if not _is_generic(t)}
        generic_only = (len(non_generic) == 0)

        BODY_PART_TOKENS = {
            "head","scalp","face","eye","ear","nose","throat","neck","chest","breast","back",
            "shoulder","arm","elbow","wrist","hand","finger","hip","groin","abdomen","stomach",
            "belly","flank","waist","buttock","leg","thigh","knee","calf","ankle","foot","toe"
        }
        # Which body parts did the user mention?
        input_parts = {t for t in tokens if t in BODY_PART_TOKENS}

        token_variants = {t: (_ck_variants(t) | {t, _ck_stem(t)}) for t in tokens}
        rows = _ck_build_row_index(df, pri_col=pri_col, sym_col=sym_col)

        from collections import defaultdict
        rows_by_cat = defaultdict(list)
        for r in rows:
            rows_by_cat[r["cat"]].append(r)

        cat_stats = {}
        cat_rows_hit = defaultdict(set)

        # ---- Stage 1: category-name hits (plus body-part boost)
        for cat, rlist in rows_by_cat.items():
            cat_tokens_union = set()
            for r in rlist:
                cat_tokens_union |= r["cat_tokens"]

            cat_hits = 0
            for t in tokens:
                vset = token_variants[t]
                if any((v in cat_tokens_union) for v in vset):
                    cat_hits += 1

            # B2 â€“ part 2: apply hint boost
            if cat in hint_boosts:
                cat_hits += 1

            cat_stats[cat] = {"cat_hits": cat_hits, "sym_hits": 0}

        # ---- Stage 2: symptoms hits (unchanged)
        for cat, rlist in rows_by_cat.items():
            sym_hits = 0
            for r in rlist:
                sym_tokens = r["sym_tokens"]
                row_hit = False
                

                cat_tokens = r["cat_tokens"]
                row_parts  = BODY_PART_TOKENS.intersection(sym_tokens | cat_tokens)

                for t in tokens:
                    vset = token_variants[t]

                    if t in non_generic:
                        # Non-generic tokens may match exactly or with tight fuzzy
                        if any((v in sym_tokens) for v in vset):
                            row_hit = True
                            break
                        if any(ok_pair(t, s) for s in sym_tokens):
                            row_hit = True
                            break
                    else:
                        # Generic token (e.g., "pain", "rash", "fever"):
                        # Count ONLY if the row mentions a body part that the user also mentioned
                        if any((v in sym_tokens) for v in vset) and (input_parts and (row_parts & input_parts)):
                            row_hit = True
                            break



                if row_hit:
                    sym_hits += 1
                    cat_rows_hit[cat].add(r["idx"])
            cat_stats[cat]["sym_hits"] = sym_hits

        # ---- scoring & selection (unchanged)
        ranking = []
        for cat, stv in cat_stats.items():
            score = 2.0 * stv["cat_hits"] + 1.0 * stv["sym_hits"]
            ranking.append((cat, score, stv["sym_hits"], len(cat_rows_hit[cat])))
        ranking.sort(key=lambda x: (x[1], x[2], x[3]), reverse=True)

        # must have â‰¥1 symptom hit; block category-only admits
        valid_cats = {cat for (cat, score, sym_hits, _n) in ranking if (sym_hits >= 1 and score >= 2.0)}

        # For generic-only + no body-part hints, gate to sensible umbrellas to avoid drift
        if generic_only and not hint_boosts:
            allowed_keywords = ("pain","discomfort","injury","bite","skin","rash","derm",
                                "breath","cough","respir","stomach","digest","abdom","urina","pee","thirst")
            def _ok_generic_cat(name: str) -> bool:
                c = _cat_norm(name)
                return any(k in c for k in allowed_keywords)
            filtered = {cat for cat in valid_cats if _ok_generic_cat(cat)}
            if filtered:
                valid_cats = filtered  # only narrow if we still have results

        # persist flag so next screen can clamp to Top-3 (you already read this later)
        st.session_state.user_data["generic_only"] = bool(generic_only)

        subset       = df.loc[[r["idx"] for r in rows if r["cat"] in valid_cats]] if valid_cats else df.iloc[0:0]
        ordered_cats = [cat for (cat, score, sym_hits, _n) in ranking if cat in valid_cats]
        return ordered_cats, subset
    
        # ---------- End local helpers ----------

    # â€” Wrap input & submit in a form so Enter works â€”
    with st.form("free_input_form"):
        symptom_input = st.text_input("Your symptoms:")
        search = st.form_submit_button("Search Symptoms")

    if search:
        # ===== CK: Category-first free-text matching =====
        if not symptom_input.strip():
            st.warning("Please enter at least one symptom to search.")
            return

        # Use your DataFrame 'db' and expected columns
        ordered_cats, subset = _ck_score_categories_and_subset(symptom_input, db,
                                                               pri_col="Primary Category",
                                                               sym_col="Symptoms")

        if subset.empty or not ordered_cats:
            # Log and show the same UX actions as before
            try:
                log_failure({
                    "timestamp": datetime.utcnow().isoformat(),
                    "step":      "free_text_match_ck",
                    "input":     symptom_input,
                    "reason":    "no_symptom_match"
                })
            except Exception:
                pass

            st.warning("â—ï¸ â€œLetâ€™s try that again. We couldnâ€™t find a close match yet. Try one or two simple symptoms (e.g., rash, fever, cough) or pick a body area. You can also speak with a doctor.")
            if st.button("Try Again"):
                st.rerun()
            if st.button("Speak to a Doctor"):
                st.session_state.page = "fallback_page"
                st.rerun()
            if st.button("Start Over"):
                st.session_state.clear()
                st.session_state.page = "welcome"
                st.rerun()
            return

        # Success: save results & advance (retain UI/UX flow)
        st.session_state.free_input_mode            = True
        st.session_state.matched_conditions         = subset
        st.session_state.user_data['free_symptoms'] = symptom_input
        st.session_state.free_primary_ranking       = ordered_cats  # ordered by relevance score
        st.session_state.page                       = "symptom_primary_category_freeinput"
        st.rerun()
        # ===== End CK block =====

    # â€” Back button outside the form â€”
    if st.button("â† Back"):
        st.session_state.page = "symptom_category"
        st.rerun()



def symptom_primary_category_freeinput_page():
    # â”€â”€ Guard: only allow free-text category pick when we actually have matches â”€â”€
    if not st.session_state.get("free_input_mode") or st.session_state.matched_conditions.empty:
        # fall back to the normal category picker
        st.session_state.page = "symptom_category"
        st.rerun()

    st.image(logo, width=80)
    st.subheader("What feels closest to how youâ€™re feeling?")

    # now safe: we know matched_conditions exists and has columns
    subset = st.session_state.matched_conditions
    current_gender = st.session_state.user_data.get('gender')
    current_age    = st.session_state.user_data.get('age')

    # --- STRICT dominance filter for generic-only queries ---
    generic_only = bool(st.session_state.user_data.get("generic_only"))
    if generic_only and not subset.empty:
        counts = subset["Primary Category"].value_counts()
        TOP_N = 3
        keep = counts.head(TOP_N).index
        subset = subset[subset["Primary Category"].isin(keep)]


    # Build primary category list in the scored order (not alphabetical)
    ranked = st.session_state.get("free_primary_ranking", [])
    ranked_set = set(ranked)

    # Fall back if ranking missing: preserve previous behavior (alphabetical of subset)
    fallback_order = [cat for cat in subset["Primary Category"].dropna().unique().tolist() if str(cat).strip()]
    ordered = [c for c in ranked if c in subset["Primary Category"].values] or sorted(fallback_order)

    primaries = []
    for cat in ordered:
        # Age/gender gating
        if (current_age is not None) and (current_age >= 15) and str(cat).strip().lower() == "pediatrics":
            continue
        if not is_gender_allowed(cat, current_gender, suppress_error=True):
            continue
        primaries.append(cat)
        

    if not primaries:
        st.warning("We found matches, but none are available for your selected gender/age.")
        if st.button("â† Back"):
            st.session_state.page = "symptom_free_input"
            st.rerun()
        return

    choice = display_grid(primaries, cols=2)
    if choice:
        st.session_state.user_data['primary_category'] = choice
        st.session_state.page = "symptom_subcategory"
        st.rerun()

    if st.button("â† Back"):
        # Back one step in the free-text flow
        st.session_state.page = "symptom_free_input"
        st.rerun()


def symptom_subcategory_page():
    st.image(logo, width=80)
    st.subheader("Letâ€™s get a bit more specificâ€”what feels closest to what youâ€™re experiencing?")

    # â”€â”€ Ensure we have a primary category â”€â”€
    primary = st.session_state.user_data.get("primary_category")
    if not primary:
        st.error("No category selected. Please start over.")
        if st.button("Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # â”€â”€ 3) Pediatricâ€mode banner â”€â”€
    if primary == "Pediatrics":
        st.info("ğŸ§¸ Pediatric mode activatedâ€”these subcategories are age-appropriate for 0â€“14 years.")

    # â”€â”€ Rest of your existing flow â”€â”€
    source = (
        st.session_state.matched_conditions
        if st.session_state.get("free_input_mode", False)
        else db
    )
    filtered = source[source["Primary Category"] == primary]
    subcats = sorted(filtered["SubCategory"].dropna().unique())
    choice = display_grid(subcats, cols=2)
    if choice:
        st.session_state.user_data["subcategory"] = choice
        st.session_state.current_condition = filtered[filtered["SubCategory"] == choice].iloc[0]
        st.session_state.page = "symptom_selection"
        st.rerun()

    if st.button("â† Back"):
        st.session_state.page = (
            "symptom_primary_category_freeinput"
            if st.session_state.get("free_input_mode", False)
            else "symptom_category"
        )
        st.rerun()

def symptom_selection_page():
    st.image(logo, width=80)
    st.subheader("Tell me about your symptoms")

    primary = st.session_state.user_data.get("primary_category")
    subcat  = st.session_state.user_data.get("subcategory")
    if not primary or not subcat:
        st.error("Category or subcategory missing. Please start over.")
        if st.button("Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # 1) Decide source: full DB for normal, matched_conditions for free-text
    source = st.session_state.matched_conditions if st.session_state.get("free_input_mode") else db

    # 2) Filter to your chosen subcategory
    subset = source[
        (source["Primary Category"] == primary) &
        (source["SubCategory"]      == subcat)
    ]

    # 3) Aggregate **all** symptoms across those rows
    options = sorted({
        s.strip()
        for row in subset["Symptoms"].dropna()
        for s   in row.split(",")
    })

    # 4) Render them
    selected = st.multiselect("Select all that apply:", options)

    # 5) Navigation
    col1, col2 = st.columns([1,3])
    with col1:
        if st.button("â† Back"):
            st.session_state.page = "symptom_subcategory"
            st.rerun()
    with col2:
        if st.button("Continue â†’"):
            st.session_state.user_data['selected_symptoms'] = selected
            st.session_state.page = "clarifying_questions"
            st.rerun()

def clarifying_questions_page():
    st.image(logo, width=80)
    st.subheader("Just a couple more quick questions to guide you")

    # 1ï¸âƒ£ Build the subset of rows for this pathway
    primary = st.session_state.user_data.get("primary_category")
    subcat  = st.session_state.user_data.get("subcategory")

    # pick source: full DB if normal, else your matched free-text subset
    source = db if not st.session_state.get("free_input_mode", False) else st.session_state.matched_conditions

    # filter to the chosen primary/subcategory
    subset = source[
        (source["Primary Category"] == primary) &
        (source["SubCategory"]      == subcat)
    ]
    if subset.empty:
        st.error("No conditions found hereâ€”please start over.")
        if st.button("Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # 2ï¸âƒ£ Stage 1: ask every unique CQ1 in this subset
    if not st.session_state.get("cq1_done"):
        cq1s    = list(subset["Clarifying Questions 1"].dropna().unique())
        answers1 = {}
        with st.form("cq1_form"):
            for i, q in enumerate(cq1s, 1):
                ans = st.radio(q, ["Yes", "No"], key=f"cq1_{i}")
                answers1[q] = ans
                answers1[f"cq1_{i}"] = ans   # NEW: store numbered key
            # summary flag for the whole stage
            answers1["cq1"] = "Yes" if any(v == "Yes" for k, v in answers1.items() if k.startswith("cq1_")) else "No"

            if st.form_submit_button("Continue â†’"):
                st.session_state.user_data["answers1"] = answers1
                st.session_state.cq1_done = True
                st.rerun()

        # Back takes you up one step (category or free-text)
        if st.button("â† Back"):
            st.session_state.page = (
                "symptom_primary_category_freeinput"
                if st.session_state.get("free_input_mode", False)
                else "symptom_subcategory"
            )
            st.rerun()
        return

    # 3ï¸âƒ£ Stage 2: only if any CQ1 was â€œYesâ€
    answers1 = st.session_state.user_data.get("answers1", {})
    if any(v == "Yes" for v in answers1.values()):
        cq2s     = list(subset["Clarifying Questions2"].dropna().unique())
        answers2 = {}
        with st.form("cq2_form"):
            for j, q in enumerate(cq2s, 1):
                ans = st.radio(q, ["Yes", "No"], key=f"cq2_{j}")
                answers2[q] = ans
                answers2[f"cq2_{j}"] = ans   # NEW: store numbered key
            # summary flag for the whole stage
            answers2["cq2"] = "Yes" if any(v == "Yes" for k, v in answers2.items() if k.startswith("cq2_")) else "No"

            if st.form_submit_button("Continue â†’"):
                merged = {**answers1, **answers2}
                st.session_state.user_data["clarifying_answers"] = merged
                st.session_state.page = "risk_flag_selection"
                del st.session_state.cq1_done
                st.rerun()

        # Back goes back into Stage 1
        if st.button("â† Back"):
            del st.session_state.cq1_done
            st.rerun()
        return

    # 4ï¸âƒ£ No â€œYesâ€ in CQ1: skip straight to risk flags
    st.session_state.user_data["clarifying_answers"] = answers1
    del st.session_state.cq1_done
    st.session_state.page = "risk_flag_selection"
    st.rerun()

# Helper: Show "No Match" message and safe next steps
def show_no_match_ui():
    st.warning(
        "I couldnâ€™t confidently match your answers to a condition in this section. "
        "Please review your answers or try different symptoms."
    )
    col1, col2 = st.columns(2)
    with col1:
        if st.button("â† Review answers"):
            st.session_state.page = "clarifying_questions"
            st.rerun()
    with col2:
        st.caption(
            "If symptoms worsen or red flags appear (severe pain, vomiting, hard/tender bulge), seek urgent care."
        )

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


def risk_flag_selection_page():
    st.image(logo, width=80)
    st.subheader("These factors can affect your care. Select any that apply, or â€œNone.â€")

    # â”€â”€ 1) Build the subset of candidate conditions â”€â”€
    cat    = st.session_state.user_data.get("primary_category")
    sub    = st.session_state.user_data.get("subcategory")
    source = (
        st.session_state.matched_conditions
        if st.session_state.get("free_input_mode", False)
        else db
    )
    subset = source[
        (source["Primary Category"] == cat) &
        (source["SubCategory"]      == sub)
    ]
    if subset.empty:
        st.error("No conditions found hereâ€”please start over.")
        return
    
    # Clear any stale risk selections before evaluating rules
    st.session_state.user_data["confirmed_risks"] = []
    
    # 3ï¸âƒ£ Prefer rows whose Labeling Rule passes for this user
    subset = subset.copy()
    
    def _passes(row):
        return evaluate_rule(row.get("Labeling Rule",""), row, st.session_state.user_data, phase="selection")

    subset["rule_ok"] = subset.apply(_passes, axis=1)
    candidates = subset[subset["rule_ok"]]

    # HARD-GATE: do not fall back to the original subset if empty
    if candidates.empty:
        show_no_match_ui()
        return
    else:
        subset = candidates

    # (Optional) Skip "Low" confidence rows entirely; remove this block if you prefer to keep them
    subset = subset[subset["Labeling Confidence"].str.lower().ne("low")]
    if subset.empty:
        show_no_match_ui()
        return

    # Ranking function used for tie-breaks

    
    def _rank_key(r):
        conf = str(r.get("Labeling Confidence", "Low")).lower()
        conf_rank = {"high": 2, "medium": 1, "low": 0}.get(conf, 0)
        acu = int(r.get("Acuity Level", 1) or 1)
        rule_len = len(str(r.get("Labeling Rule", "")))
        name = str(r.get("Condition", ""))
        # Sort: higher confidence, higher acuity, shorter rule, Aâ†’Z
        return (-conf_rank, -acu, rule_len, name)

    # Sort by a single helper column that holds the tuple (lexicographic order)
    subset = (
        subset
        .assign(__rk=subset.apply(_rank_key, axis=1))
        .sort_values("__rk", ascending=True)
        .drop(columns="__rk")
    )

    # â”€â”€ 2) Map CQ2 â€œYesâ€ answers back to rows â”€â”€
    answers = st.session_state.user_data.get("clarifying_answers", {})
    flagged = []
    for idx, row in subset.iterrows():
        q2 = row["Clarifying Questions2"]
        if pd.notna(q2) and answers.get(q2) == "Yes":
            flagged.append(idx)

    # â”€â”€ 3) Triaging logic, always run â”€â”€
    if len(flagged) == 1:
        chosen_idx = flagged[0]
    elif len(flagged) > 1:
        # Apply the same ranking only within the flagged set
        df_flagged = subset.loc[flagged].copy()
        df_flagged = (
            df_flagged
            .assign(__rk=df_flagged.apply(_rank_key, axis=1))
            .sort_values("__rk", ascending=True)
        )
        chosen_idx = df_flagged.index[0]
    else:
        # No CQ2 flags â†’ pick the top-ranked candidate overall
        subset_ranked = (
            subset
            .assign(__rk=subset.apply(_rank_key, axis=1))
            .sort_values("__rk", ascending=True)
        )
        chosen_idx = subset_ranked.index[0]

    # â”€â”€ 4) Save the final condition â”€â”€
    st.session_state.current_condition = subset.loc[chosen_idx]

    # â”€â”€ 5) Render its RiskFlags â”€â”€
    cond = st.session_state.current_condition
    raw = str(cond.get("RiskFlags", "") or "")
    flags = [f.strip() for f in raw.split(",") if f.strip()]

    selected = []
    for flag in flags:
        if st.checkbox(flag, key=f"rf_{flag}"):
            selected.append(flag)

    none = st.checkbox("None / Not Applicable", key="rf_none")
    if none and selected:
        st.warning("â€œNoneâ€ cannot be combined with other selections; only â€œNoneâ€ will be used.")

    # â”€â”€ 6) Continue â†’ record and go to Results â”€â”€
    if st.button("Continue"):
        st.session_state.user_data["confirmed_risks"] = [] if none else selected
        st.session_state.page = "results"
        st.rerun()

    # â† Back â†’ clarifiers
    if st.button("â† Back"):
        st.session_state.page = "clarifying_questions"
        st.rerun()



import re

# REPLACE your evaluate_rule with this
def evaluate_rule(rule_str: str, condition: dict, user_data: dict, *, phase: str = "selection") -> bool:
    """
    Evaluate Labeling Rule against the user's inputs.
    phase="selection": ignore risk_flag atoms so valid rows aren't blocked pre-pick
    phase="results":   enforce risk_flag atoms normally
    """
    import re

    sel_syms = {s.strip().lower() for s in user_data.get("selected_symptoms", []) if isinstance(s, str)}
    sel_rfs  = {r.strip().lower() for r in user_data.get("confirmed_risks", []) if isinstance(r, str)}
    answers  = {str(k).lower(): str(v).strip().lower()
                for k, v in user_data.get("clarifying_answers", {}).items()}

    cq1_any = any((k.startswith("cq1_") and v == "yes") for k, v in answers.items())
    cq2_any = any((k.startswith("cq2_") and v == "yes") for k, v in answers.items())
    answers["cq1"] = "yes" if cq1_any else "no"
    answers["cq2"] = "yes" if cq2_any else "no"

    def eval_atom(atom: str) -> bool:
        atom = atom.strip()
        m = re.match(r"^symptom\s*==\s*(.+)$", atom, re.IGNORECASE)
        if m:
            return m.group(1).strip().lower() in sel_syms
        m = re.match(r"^risk_flag\s*==\s*(.+)$", atom, re.IGNORECASE)
        if m:
            v = m.group(1).strip().lower()
            return True if phase == "selection" else (v in sel_rfs)
        m = re.match(r"^cq(\d+)\s*==\s*yes$", atom, re.IGNORECASE)
        if m:
            n = m.group(1)
            if answers.get(f"cq{n}", "") == "yes":
                return True
            return any(k.startswith(f"cq{n}_") and v == "yes" for k, v in answers.items())
        return False

    parts = re.split(r"(\bAND\b|\bOR\b|\(|\))", str(rule_str or ""), flags=re.IGNORECASE)
    expr = ""
    for t in parts:
        t = t.strip()
        if not t: continue
        if re.fullmatch(r"AND", t, re.IGNORECASE):
            expr += " and "
        elif re.fullmatch(r"OR", t, re.IGNORECASE):
            expr += " or "
        elif t in ("(", ")"):
            expr += t
        else:
            expr += str(eval_atom(t))
    try:
        return bool(eval(expr)) if expr else False
    except Exception:
        return False



def make_recommendation(condition: dict, user_flags: dict, risk_flags: list) -> str:
    # Determine escalation
    acuity = condition.get("Acuity Level", 0)
    is_esc = bool(risk_flags) or (acuity == 3)

    # Confidence guard
    conf = condition.get("Labeling Confidence", "Low")
    if conf == "Low":
        return ""

    # Rule match guard (allow escalation)
    rule_ok = evaluate_rule(condition["Labeling Rule"], condition, st.session_state.user_data, phase="results")


    # â¬… NEW: enforce rule before building recommendation
    if not rule_ok and not is_esc:
        return ""

    # Certainty phrase
    certainty = "very likely" if conf == "High" else "symptoms suggest"

    # Pick templates
    if is_esc:
        base_tmpl = condition.get("Escalated Narrative Template (Risk Flags Present)", "")
        rec_text = condition.get("Escalated Recommendation", "")
    else:
        base_tmpl = condition.get("Default Narrative Template", "")
        rec_text = condition.get("Default Recommendation", "")

    # Render base with placeholders
    base = base_tmpl.format(
        certainty=certainty,
        risk_flags=", ".join(risk_flags),
        default_rec=condition.get("Default Recommendation", ""),
        escalated_rec=condition.get("Escalated Recommendation", "")
    )

    # Build recommendation without duplication
    if ('{default_rec}' in base_tmpl) or ('{escalated_rec}' in base_tmpl):
        recommendation = base
    else:
        recommendation = f"{base} {rec_text}".strip()

     #Append emergency note marker
    note = condition.get("Emergency Narrative (If Applicable)", "").strip()
    if note:
        recommendation += f"\n\nğŸš¨ Important: {note}"

    return recommendation


def results_page():
    # Header and Title
    st.image(logo, width=80)
    #st.header("Based on your answers, your likely condition is:")

    # Fetch the chosen condition
    condition = st.session_state.current_condition
    if condition is None:
        st.error("No condition selected. Please start over.")
        if st.button("ğŸ”„ Start New Check"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # Show the condition's name
    #condition_title = condition.get("Condition", "")
    #st.subheader(condition_title)

    # Determine baseline acuity (for card color)
    if st.session_state.get("free_input_mode"):
        baseline_rank = int(st.session_state.matched_conditions.get("Acuity Level", 0).max())
    else:
        baseline_rank = int(condition.get("Acuity Level", 0) or 0)

    # Gather & sanitize risk flags (avoid accidental truthy [""])
    raw_flags  = st.session_state.user_data.get("confirmed_risks", [])
    risk_flags = [rf.strip() for rf in raw_flags if isinstance(rf, str) and rf.strip()]

    # â€”â€”â€” Assemble user_flags with normalized keys â€”â€”â€”
    user_data  = st.session_state.user_data
    user_flags = {}

    # 1) Symptoms from selected_symptom
    for sym in user_data.get("selected_symptoms", []):
        key = sym.strip().lower().replace(" ", "_")
        user_flags[key] = True

    # 2) Clarifiers from clarifying_answers
    for question, ans in user_data.get("clarifying_answers", {}).items():
        if ans == "Yes":
            key = question.strip().lower().replace(" ", "_")
            user_flags[key] = True

    # 3) Risk flags
    for rf in risk_flags:
        key = rf.strip().lower().replace(" ", "_")
        user_flags[key] = True

    # Generate recommendation (string may include an appended emergency line in older builds)
    recommendation = make_recommendation(condition, user_flags, risk_flags)

    if recommendation:
        # âœ… Only show headline when recommendation exists
        st.header("Based on your answers, your likely condition is:")

        # â¬‡ï¸ Move these two lines here
        condition_title = condition.get("Condition", "")
        st.subheader(condition_title)
    
    else:
        fallback_html = """
        <div style="
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            border-radius: 12px;
            padding: 24px;
            font-size: 1.25rem;
            line-height: 1.6;
            color: #3a2e00;
            font-weight: 500;
            text-align: center;
        ">
            I couldnâ€™t make a confident match for your symptoms.<br>
            That happens sometimes, and it simply means a human touch is needed.<br>
            <strong>Consider reaching out to a healthcare professional â€” or you can try another check with more details.</strong>
        </div>
        """
        st.markdown(fallback_html, unsafe_allow_html=True)

        # Add space before buttons
        st.markdown("<div style='margin-top: 20px;'></div>", unsafe_allow_html=True)

        col1, col2 = st.columns(2)
        with col1:
            if st.button("ğŸ”„ Start Over", use_container_width=True):
                st.session_state.clear()
                st.session_state.page = "welcome"
                st.rerun()
        with col2:
            if st.button("ğŸ“… Schedule an Appointment", use_container_width=True):
                st.info("Appointment scheduling flow will be implemented here.")
        return

    # Display recommendation or fallback with styled blocks
    if recommendation:
        # Your escalation rule for card color:
        is_esc = (baseline_rank == 3) or bool(risk_flags)
        block_class = "report-block" if is_esc else "report-block report-block--ok"

        # If the recommendation string contains an appended emergency line,
        # strip it from the main text to avoid duplication (we render emergency separately).
        parts = recommendation.split('\n\nğŸš¨ Important: ')
        main_text = parts[0].strip()

        # MAIN CARD (escape DB content)
        safe_main = html.escape(main_text).replace('\n','<br>')
        card_html = (
            f"<div class='{block_class}' style='font-size: 1.2rem;'>"
            f"{safe_main}"
            "</div>"
        )

        # Optional referral line below the card (escape too)
        ref_text = (condition.get("Referral", "") or "").strip()
        if ref_text:
            card_html += (
                "<div style='margin-top:20px; font-size:1.2rem;'>"
                f" ğŸ©º <strong>{html.escape(ref_text)}</strong></div>"
            )

        st.markdown(card_html, unsafe_allow_html=True)

        # EMERGENCY NOTE â€” render once, as a separate block
        emergency = (condition.get("Emergency Narrative (If Applicable)", "") or "").strip()
        if emergency:
            st.markdown(
                f"<div class='emergency-block' style='font-size: 1.2rem; margin-bottom: 20px;'>"
                f"ğŸš¨ Important: {html.escape(emergency)}</div>",
                unsafe_allow_html=True
        )

    else:
        # Fallback amber (mobile-friendly)
        warn_html = (
            "<div class='report-block report-block--warn'>"
            "Iâ€™m not able to match a condition confidently. Please consider consulting a "
            "healthcare professional for a definitive evaluation."
            "</div>"
        )
        st.markdown(warn_html, unsafe_allow_html=True)

    # Optional: Schedule Appointment button
    if condition.get("Referral") and st.button("ğŸ“… Schedule an Appointment"):
        st.info("Appointment scheduling will be available soon.")

    # Download report & New Check buttons (single set; CSS centers on mobile only)
    col1, col2 = st.columns([1, 1])

    with col1:
        report_text = generate_report()
        st.download_button(
            label="ğŸ“„ Download Full Report",
            data=report_text,
            file_name=f"{condition_title}_report.txt",
            key="dl_report"
        )

    with col2:
        if st.button("ğŸ”„ Start New Check", key="newcheck"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()

   # â¬‡ï¸ CSS comes immediately after these buttons
    st.markdown("""
    <style>
    @media (max-width: 640px) {
      /* Center the download button itself */
      div[data-testid="stDownloadButton"] > button {
        display: block !important;
        margin-left: auto !important;
        margin-right: auto !important;
      }
    }
    </style>
    """, unsafe_allow_html=True)



def fallback_page():
    st.image(logo, width=80)
    st.warning("I couldnâ€™t find a clear match for your symptoms, which could mean theyâ€™re mild or need professional evaluation.")
    st.markdown("**Would you like to speak with a Doctor about this?**")
    col1, col2, col3 = st.columns([1,1,1])
    with col1:
        if st.button("ğŸ“… Schedule an Appointment"):
            st.info("Appointment scheduling flow will be implemented here.")
    with col2:
        if st.button("ğŸ”„ Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
    with col3:
        if st.button("â† Back"):
            st.session_state.page = "clarifying_questions"
            st.rerun()

PAGES = {
    "welcome": welcome_page,
    "user_info": user_info_page,
    "symptom_category": symptom_category_page,
    "symptom_free_input": symptom_free_input_page,
    "symptom_primary_category_freeinput": symptom_primary_category_freeinput_page,
    "symptom_subcategory": symptom_subcategory_page,
    "symptom_selection": symptom_selection_page,
    "clarifying_questions": clarifying_questions_page,
    "risk_flag_selection": risk_flag_selection_page,
    "results": results_page,
    "fallback_page": fallback_page,
    "analytics": analytics_page,
}
# ---- Auth gate: show login until authenticated ----
if not st.session_state.get("logged_in", False):
    login_page()
    st.stop()

PAGES[st.session_state.page]()