# -*- coding: utf-8 -*-
"""App_v5.5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E0X9U1nI-2YPh5tNkrh-K8g3lFZhDf9L
"""

import streamlit as st
import pandas as pd
from PIL import Image
import re
from difflib import SequenceMatcher
import os
import csv
from datetime import datetime
import html



LOG_PATH = "failure_log.csv"

GENERIC_TOKENS = {"pain", "ache", "aches", "soreness", "discomfort",
                  "rash", "rashes", "fever", "cough", "vomiting",
                  "diarrhea", "dizziness", "fatigue", "weakness"}

# New: treat ‚Äútenderness‚Äù as a generic synonym so ‚Äúbreast pain‚Äù ‚âà ‚Äúbreast tenderness‚Äù
GENERIC_SYNONYMS = {"pain", "ache", "aches", "soreness", "discomfort", "tenderness",
                    "rash", "rashes", "fever", "cough", "vomiting",
                    "diarrhea", "dizziness", "fatigue", "weakness"}

GENERIC_SYNONYMS |= {"hives","urticaria","exanthem","dermatitis","eruption","itch","itchy","itching","pruritus"}

# Map each generic to common synonyms seen in the DB
GENERIC_FAMILY = {
    "pain": {"pain","ache","aches","soreness","discomfort","tenderness","cramp","cramps","spasm","spasms"},
    "rash": {"rash","rashes","hives","urticaria","exanthem","dermatitis","eruption"},
    "fever": {"fever","pyrexia","temperature"},
    "cough": {"cough","coughing"},
    "vomiting": {"vomiting","vomit","emesis","throwing","throwing up"},
    "diarrhea": {"diarrhea","diarrhoea","loose","watery","stools","stool"},
    "dizziness": {"dizziness","vertigo","lightheadedness"},
    "fatigue": {"fatigue","tiredness","malaise"},
    "weakness": {"weakness","asthenia"},
}

# Kill-switch for enforcing weak anchors (defaults OFF)
STRICT_WEAK_ANCHORS = st.session_state.get("STRICT_WEAK_ANCHORS", False)

if 'STRICT_WEAK_ANCHORS' not in st.session_state:
    st.session_state["STRICT_WEAK_ANCHORS"] = True


WEAK_ANCHORS = {"skin", "body", "area", "surface", "left","right","upper","lower","middle","central","lateral",
    "inner","outer"}

# --- Feature-flag safe defaults and tiny helper ---
if "STRICT_GENERIC_MODE" not in st.session_state:
    st.session_state["STRICT_GENERIC_MODE"] = False

def _flag(name: str) -> bool:
    return bool(st.session_state.get(name, False))

# --- Generic ‚Üí primary-category keywords (broad domains) ---
GENERIC_TO_CATKEYS = {
    "pain":     {"pain","discomfort","injury","bite","swelling"},
    "rash":     {"skin","rash","dermat"},
    "cough":    {"breath","cough","respir"},
    "vomiting": {"stomach","digest","abdom"},
    "diarrhea": {"stomach","digest","abdom","rectal","bowel"},
    "dizziness":{"ear","nose","throat","head"},
    "fatigue":  {"gen","pain","discomfort"},
    "weakness": {"gen","pain","discomfort"},
    "fever":    {"breath","cough","respir","stomach","digest","abdom"},
}


def log_failure(record: dict):
    file_exists = os.path.isfile(LOG_PATH)
    with open(LOG_PATH, "a", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=list(record.keys()))
        if not file_exists:
            writer.writeheader()
        writer.writerow(record)

def analytics_page():
    st.header("üìä App Failure Report")
    if not os.path.isfile(LOG_PATH):
        st.info("No failures logged yet.")
        return

    df = pd.read_csv(LOG_PATH, parse_dates=["timestamp"])
    st.subheader("Recent Failures")
    st.dataframe(df.sort_values("timestamp", ascending=False).head(20))

    st.subheader("Failures by Reason")
    counts = df["reason"].value_counts().reset_index()
    counts.columns = ["Reason","Count"]
    st.table(counts)

    st.subheader("Suggested FreeTextMap Additions")
    sugg = suggest_freetext_mappings(db, top_n=30)
    if not sugg.empty:
        st.dataframe(sugg)



def suggest_freetext_mappings(db, top_n=20):
    vocab = set()
    for s in db["Symptoms"].dropna().astype(str).tolist():
        for tok in re.findall(r"[A-Za-z]{3,}", s.lower()):
            vocab.add(tok)

    if not os.path.isfile(LOG_PATH):
        return pd.DataFrame()

    df = pd.read_csv(LOG_PATH)
    misses = df[df["reason"] == "no_symptom_match"]["input"].str.lower().value_counts().head(top_n)
    suggestions = []
    for phrase, cnt in misses.items():
        toks = re.findall(r"[A-Za-z]{3,}", phrase)
        nearest = []
        for t in toks:
            best = max(vocab, key=lambda v: SequenceMatcher(None, t, v).ratio(), default=None)
            if best:
                nearest.append((t, best))
        suggestions.append({"input_phrase": phrase, "count": cnt, "nearest_tokens": nearest})
    return pd.DataFrame(suggestions)

def stem(word: str) -> str:
    w = word.lower().strip()
    for suf in ("ing", "ion", "ed", "s", "ness", "able"):
        if w.endswith(suf):
            return w[: -len(suf)]
    return w

st.set_page_config(page_title="LEXY... LexMedical AI Triage System", page_icon="ü©∫", layout="centered")

# --- Mobile-friendly, high-contrast styles ---
st.markdown("""
<style>
.report-block {
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 10px;
  padding: 16px;
  font-size: 1rem;
  line-height: 1.6;
  color: #2b0000;
  word-wrap: break-word;
  overflow-wrap: anywhere;
}
.report-block--ok {
  background-color: #d4edda;
  border-color: #c3e6cb;
  color: #062b0a;
}            
.report-block--warn {
  background-color: #fff3cd;
  border: 1px solid #ffeeba;
  color: #3a2e00;
}
.emergency-block {
  margin-top: 16px;
  padding: 14px;
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 10px;
  font-weight: 600;
  font-size: 1rem;
  line-height: 1.6;
  color: #2b0000;
  word-wrap: break-word;
  overflow-wrap: anywhere;
}
@media (max-width: 640px) {
  .report-block, .emergency-block {
    font-size: 1.05rem;
    line-height: 1.7;
    padding: 18px;
  }
  .stButton > button { width: 100% !important; }
}
</style>
""", unsafe_allow_html=True)

# Initialize session state safely
if 'free_input_mode' not in st.session_state:
    st.session_state.free_input_mode = False
if 'page' not in st.session_state:
    st.session_state.page = "welcome"
if 'user_data' not in st.session_state:
    st.session_state.user_data = {}
if 'current_condition' not in st.session_state:
    st.session_state.current_condition = None
if 'confirmed_risks' not in st.session_state:
    st.session_state.confirmed_risks = []
if 'matched_conditions' not in st.session_state:
    st.session_state.matched_conditions = pd.DataFrame()
if 'logged_in' not in st.session_state:
    st.session_state.logged_in = False

@st.cache_data(ttl=60)
def load_data():
    df = pd.read_excel("SymptomBotDB.xlsx")
    df.columns = df.columns.astype(str).str.replace("\u00A0"," ", regex=False).str.strip()
    # ‚îÄ‚îÄ Normalize every header: remove leading/trailing whitespace ‚îÄ‚îÄ
    df.columns = df.columns.str.strip()
    return df
# --- Free-text normalization driven by Excel (FreeTextMap sheet) ---

@st.cache_data(ttl=60)
def load_freetext_map() -> dict:
    """
    Reads SymptomBotDB.xlsx -> sheet 'FreeTextMap' with columns:
      from_phrase, to_phrase  (case-insensitive)
    Returns dict {from_phrase_lower: to_phrase_lower}.
    If the sheet is missing, returns {} (no-op).
    """
    try:
        df_map = pd.read_excel("SymptomBotDB.xlsx", sheet_name="FreeTextMap")
        df_map.columns = df_map.columns.str.strip().str.lower()
        if not {"from_phrase","to_phrase"}.issubset(df_map.columns):
            return {}
        # build lowercase map, drop blanks
        m = {}
        for _, r in df_map.iterrows():
            fp = str(r["from_phrase"]).strip().lower()
            tp = str(r["to_phrase"]).strip().lower()
            if fp and tp and fp != "nan" and tp != "nan":
                m[fp] = tp
        return m
    except Exception:
        return {}

FT_MAP = load_freetext_map()

# c) fuzzy-stem match across token pairs (safer)
def ok_pair(us, ds):
    if len(us) < 4 or len(ds) < 4:
        return False
    if not (us[0] == ds[0] or us in ds or ds in us):
        return False

    # adaptive threshold
    base = 0.80
    if len(us) >= 6 and len(ds) >= 6:
        base = 0.74  # allow one typo on long words
    return SequenceMatcher(None, us, ds).ratio() >= base


def normalize_free_text(raw: str) -> str:
    """
    Minimal, safe normalization:
      - lowercase + trim
      - unify curly quotes
      - apply FreeTextMap replacements (longest-first)
      - a couple high-impact typo/alias fixes
    Returns a SINGLE normalized string you feed into your existing matcher.
    """
    if not raw:
        return ""
    text = raw.strip().lower()

    # normalize curly quotes to ascii to avoid miss matches
    text = (text
            .replace("‚Äô", "'")
            .replace("‚Äò", "'")
            .replace("‚Äú", '"')
            .replace("‚Äù", '"'))

    # tiny typo fix that bites often
    text = text.replace("heatbeat", "heartbeat")

    # Apply Excel-driven phrase replacements, longest keys first to avoid partial shadowing
    if FT_MAP:
        for k in sorted(FT_MAP.keys(), key=len, reverse=True):
            pat = r'(?<!\w)' + re.escape(k) + r'(?!\w)'
            text = re.sub(pat, FT_MAP[k], text)
    
    text = apply_stop_phrases(text)
    return text

# Misleading phrases that shouldn't trigger body-part detection
STOP_PHRASES = {
    "side effects": "side_effects",  # neutralize "side" so it won't map to flank
}

def apply_stop_phrases(text: str) -> str:
    """Replace misleading phrases with inert tokens AFTER normalization."""
    t = text or ""
    for bad, safe in STOP_PHRASES.items():
        t = t.replace(bad, safe)
    return t


def load_logo():
    return Image.open("logo.png")

db = load_data()
logo = load_logo()

# ===== Body-part synonyms ‚Üí category hints (resolved to DB labels) =====

def _cat_norm(s: str) -> str:
    """Canonicalize for matching category names (lowercase, strip, normalize quotes)."""
    return str(s).strip().lower().replace("‚Äô", "'").replace("‚Äò", "'")

# Build map of canonical‚Üíexact label from the DB (so hints always resolve to real labels)
CAT_CANON = {}
for c in db["Primary Category"].dropna().astype(str).unique():
    key = _cat_norm(c)
    # First one wins; we want the exact label as it appears in the DB
    CAT_CANON.setdefault(key, c)

# Tight, human-curated body-part aliases with intended category hints.
# ‚ö†Ô∏è Hints are written using the **exact** strings from your DB above.
BODY_PART_SYNONYMS = {
    # Head & neck
    "head":         {"aliases": {"head", "skull"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)", "Trauma, Burns & Bites"]},
    "face":         {"aliases": {"face","facial","cheek","cheeks","jaw","jawbone","chin"}, "category_hints": ["ENT (Ear/Nose/Throat)","Dentistry (Teeth/Gums)","Dermatology (Skin/Rash)","Ophthalmology (Red Eye)"]},
    "scalp":        {"aliases": {"scalp"}, "category_hints": ["Dermatology (Skin/Rash)"]},
    "eye":          {"aliases": {"eye","eyes","eyelid","eyelids"}, "category_hints": ["Ophthalmology (Red Eye)"]},
    "ear":          {"aliases": {"ear","ears"}, "category_hints": ["ENT (Ear/Nose/Throat)"]},
    "nose":         {"aliases": {"nose","nostril","nostrils"}, "category_hints": ["ENT (Ear/Nose/Throat)","Respiratory (Cough/Breathing)"]},
    "throat":       {"aliases": {"throat","tonsil","tonsils"}, "category_hints": ["ENT (Ear/Nose/Throat)","Respiratory (Cough/Breathing)"]},
    "mouth_teeth":  {"aliases": {"mouth","gum","gums","tooth","teeth","tongue","lip","lips"}, "category_hints": ["Dentistry (Teeth/Gums)","ENT (Ear/Nose/Throat)"]},
    "neck":         {"aliases": {"neck","nape"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Endocrine (Lump/Swelling)"]},

    # Chest, back, abdomen
    "chest":        {"aliases": {"chest","rib","ribs"}, "category_hints": ["Respiratory (Cough/Breathing)","MSK & Rheumatology (Body/Joint Pain)","Emergency (Time-critical)"]},
    "breast":       {"aliases": {"breast","breasts","nipple","nipples","areola"}, "category_hints": ["Women‚Äôs Health","Endocrine (Lump/Swelling)"]},
    "back":         {"aliases": {"back","upper back","lower back","waist"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Trauma, Burns & Bites"]},
    "abdomen":      {"aliases": {"abdomen","abdominal","belly","tummy","stomach","tommy"}, "category_hints": ["Gastrointestinal (Abdominal)"]},
    "flank_side":   {"aliases": {"flank","side"}, "category_hints": ["Increased thirst/urination","Gastrointestinal (Abdominal)"]},
    "hip":          {"aliases": {"hip","hips"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Trauma, Burns & Bites"]},
    "groin":        {"aliases": {"groin","crotch"}, "category_hints": ["Urology & Sexual Health (UTI/STIs)","Men‚Äôs Health","Women‚Äôs Health"]},

    # Buttocks & anorectal
    "buttocks":     {"aliases": {"buttocks","butt","bum","backside","behind","ass"}, "category_hints": ["Colorectal & Anorectal (Bowel)","Dermatology (Skin/Rash)"]},
    "anus_rectum":  {"aliases": {"anus","anal","rectum","rectal"}, "category_hints": ["Colorectal & Anorectal (Bowel)"]},

    # Upper limbs
    "shoulder":     {"aliases": {"shoulder","shoulders","collarbone","clavicle"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Trauma, Burns & Bites"]},
    "arm":          {"aliases": {"arm","arms"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Trauma, Burns & Bites","Endocrine (Lump/Swelling)"]},
    "elbow":        {"aliases": {"elbow","elbows"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Trauma, Burns & Bites"]},
    "forearm":      {"aliases": {"forearm","forearms"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Trauma, Burns & Bites"]},
    "wrist":        {"aliases": {"wrist","wrists"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Trauma, Burns & Bites"]},
    "hand":         {"aliases": {"hand","hands","palm","finger","fingers","thumb","thumbs"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Dermatology (Skin/Rash)","Trauma, Burns & Bites"]},

    # Lower limbs
    "leg":          {"aliases": {"leg","legs"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Trauma, Burns & Bites","Endocrine (Lump/Swelling)"]},
    "thigh":        {"aliases": {"thigh","thighs","lap"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Trauma, Burns & Bites"]},
    "knee":         {"aliases": {"knee","knees"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Trauma, Burns & Bites","Endocrine (Lump/Swelling)"]},
    "calf":         {"aliases": {"calf","calves"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Endocrine (Lump/Swelling)"]},
    "shin":         {"aliases": {"shin","shins"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Trauma, Burns & Bites"]},
    "ankle":        {"aliases": {"ankle","ankles"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Trauma, Burns & Bites","Endocrine (Lump/Swelling)"]},
    "foot":         {"aliases": {"foot","feet","heel","heels","sole","toes","toe"}, "category_hints": ["MSK & Rheumatology (Body/Joint Pain)","Dermatology (Skin/Rash)","Trauma, Burns & Bites","Endocrine (Lump/Swelling)"]},

    # Genitals (gender gating happens later)
    "male_genitals":   {"aliases": {"penis","testicle","testicles","scrotum","balls","manhood","dick"}, "category_hints": ["Men‚Äôs Health","Urology & Sexual Health (UTI/STIs)"]},
    "female_genitals": {"aliases": {"vagina","vaginal","vulva","labia","clitoris","womanhood","private part"}, "category_hints": ["Women‚Äôs Health","Urology & Sexual Health (UTI/STIs)"]},

    # Skin (general)
    "skin":         {"aliases": {"skin"}, "category_hints": ["Dermatology (Skin/Rash)"]},
}

# Resolve every hint to the exact DB label; drop/flag any that don‚Äôt resolve
BP_ALIAS_TO_HINTS = {}
_BAD_HINTS = []  # if any, fix the spelling/spacing in BODY_PART_SYNONYMS

for _canon, data in BODY_PART_SYNONYMS.items():
    for alias in data["aliases"]:
        resolved = set()
        for hint in data["category_hints"]:
            key = _cat_norm(hint)
            real = CAT_CANON.get(key)
            if real is None:
                _BAD_HINTS.append((alias, hint))
            else:
                resolved.add(real)
        if resolved:
            BP_ALIAS_TO_HINTS[alias.lower()] = resolved

# Optional: print unresolved hints to Streamlit sidebar (visible only to admins/devs)
if _BAD_HINTS:
    st.sidebar.warning("Unrecognized category_hints in BODY_PART_SYNONYMS (check spelling):")
    for alias, hint in _BAD_HINTS:
        st.sidebar.write(f"alias='{alias}'  hint='{hint}'  ‚Üí NOT IN DB")
# ===== End body-part hints =====


# --- UTILITY FUNCTIONS ---


def is_gender_allowed(primary_category, gender, suppress_error=False):
    primary_category = primary_category.replace("‚Äô", "'")
    WOMEN_SPECIFIC = {
        "Women's Health", "Pelvic Inflammatory Disease", "Breast Lump",
        "Cervical Cancer", "Menopause", "Fibroids", "Heavy Menstrual Bleeding",
        "Yeast Infection", "Bacterial Vaginosis", "Endometriosis", "PCOS",
        "Pelvic Organ Prolapse", "Ovarian Cyst", "Ectopic Pregnancy"
    }
    MEN_SPECIFIC = {
        "Men's Health", "Prostatitis", "Testicular Torsion",
        "Benign Prostatic Hyperplasia", "Varicocele", "Balanitis"
    }
    if gender == "Male" and primary_category in WOMEN_SPECIFIC:
        if not suppress_error:
            st.error("This category is not available for your selected gender")
        return False
    if gender == "Female" and primary_category in MEN_SPECIFIC:
        if not suppress_error:
            st.error("This category is not available for your selected gender")
        return False
    return True

def _row_allowed_for_gender(row, gender: str) -> bool:
    """Return True if this DB row is appropriate for the user's gender."""
    if not gender:
        return True
    # First, reuse your existing gate with no UI noise
    try:
        if not is_gender_allowed(str(row.get("Condition","")), gender, suppress_error=True):
            return False
    except Exception:
        pass
    # Then heuristic keywords across subcategory + condition + symptoms
    text = f"{row.get('SubCategory','')} {row.get('Condition','')} {row.get('Symptoms','')}".lower()
    male_terms   = ("male", "prostate", "penile", "testicular", "scrot", "ejacul", "erectile")
    female_terms = ("female", "vaginal", "vulva", "labia", "uterine", "cervic", "ovarian", "menstrual", "pregnan")
    if gender == "Female" and any(t in text for t in male_terms):
        return False
    if gender == "Male" and any(t in text for t in female_terms):
        return False
    return True

def display_grid(items, cols=3):
    rows = [items[i:i + cols] for i in range(0, len(items), cols)]
    for row in rows:
        columns = st.columns(len(row))
        for col, item in zip(columns, row):
            with col:
                if st.button(item, use_container_width=True):
                    return item
    return None

def generate_report():
    condition = st.session_state.current_condition
    user = st.session_state.user_data
    report = f"""
LEXAI SYMPTOM CHECKER REPORT
============================

Patient Details:
- Age: {user.get('age', 'N/A')}
- Gender: {user.get('gender', 'N/A')}

Assessment:
- Likely Condition: {condition['Condition'] if condition is not None else 'N/A'}
- Risk Factors: {', '.join(st.session_state.confirmed_risks) if st.session_state.confirmed_risks else 'None'}

Recommendation:
{condition['Escalated Recommendation' if st.session_state.get('is_high_risk') else 'Default Recommendation'] if condition is not None else ''}
"""
    return report

def similarity(a, b):
    return SequenceMatcher(None, a, b).ratio()

def match_conditions_by_symptoms(input_text, db):
    input_symptoms = [sym.strip().lower() for sym in input_text.split(",") if sym.strip()]
    matched_conditions = []
    for _, row in db.iterrows():
        db_symptoms = [sym.lower().strip() for sym in str(row["Symptoms"]).split(",") if sym.strip()]
        for user_sym in input_symptoms:
            for db_sym in db_symptoms:
                if user_sym in db_sym or db_sym in user_sym or similarity(user_sym, db_sym) >= 0.65:
                    matched_conditions.append(row)
                    break
            else:
                continue
            break
    return pd.DataFrame(matched_conditions).drop_duplicates()

def login_page():
    st.title("Lexy- Carekonnect Symptom Checker Login")

    # Create a form for login
    with st.form("login_form"):
        password = st.text_input("Enter Password", type="password")
        submit_button = st.form_submit_button("Login")

    # Check password
    if submit_button:
        if password == "lexmedical":
            st.session_state.logged_in = True
            st.session_state.page = "welcome"
            st.rerun()
        else:
            st.error("Incorrect password. Please try again.")




def welcome_page():
    # ‚îÄ‚îÄ‚îÄ 1) Inject custom CSS for styling ‚îÄ‚îÄ‚îÄ
    st.markdown("""
    <style>
      /* Center and size the logo container */
      .logo-container {
        text-align: center;
        margin-bottom: 1.5rem;
      }
      /* Title styling */
      .welcome-title {
        text-align: center;
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 1rem;
      }
      /* Body text styling */
      .welcome-text {
        max-width: 600px;
        margin: 0 auto 2rem auto;
        font-size: 1.1rem;
        line-height: 1.6;
        color: #444;
      }
      /* Button sizing and coloring */
      .stButton > button {
        width: 220px;
        height: 50px;
        font-size: 1.1rem;
        border-radius: 8px;
        border: none;
        margin-top: 1rem;
      }
      .stButton > button[disabled] {
        background-color: #bbb !important;
        color: #fff !important;
        cursor: not-allowed;
      }
      .stButton > button:not([disabled]) {
        background-color: #e63946 !important;
        color: #fff !important;
      }
      /* Footer styling */
      .footer {
        text-align: center;
        font-size: 0.9rem;
        color: #666;
        margin-top: 3rem;
      }
    </style>
    """, unsafe_allow_html=True)

    # ‚îÄ‚îÄ‚îÄ 2) Logo ‚îÄ‚îÄ‚îÄ
    st.markdown("<div class='logo-container'>", unsafe_allow_html=True)
    st.image(logo, width=120)
    st.markdown("</div>", unsafe_allow_html=True)

    # ‚îÄ‚îÄ‚îÄ 3) Welcome text ‚îÄ‚îÄ‚îÄ
    st.markdown("<div class='welcome-title'>Lexy- AI Based Symptom Checker</div>", unsafe_allow_html=True)
    st.markdown("""
      <div class='welcome-text'>
         <strong>Hi üëã, I‚Äôm Lexy ‚Äî here to help you make sense of your symptoms and feel more in control of your health.</strong><br><br>
        Lexy is an AI Triage tool that helps users better understand their symptoms and suggests next steps‚Äîwhether that‚Äôs self-care, seeing a provider, or seeking urgent help.<br>
        It does not offer medical diagnoses and is not a substitute for care from a qualified health professional.<br><br>
        This tool is not recommended for children under 16, pregnant individuals, or those with multiple health conditions.<br><br>
        <strong>In case of emergency</strong>‚Äîsuch as chest pain, severe bleeding, or difficulty breathing‚Äîplease call emergency services or go to the nearest hospital.
      </div>
    """, unsafe_allow_html=True)

    # ‚îÄ‚îÄ‚îÄ 4) Confirmation checkbox ‚îÄ‚îÄ‚îÄ
    confirm = st.checkbox("I have read and understood the above")

    # ‚îÄ‚îÄ‚îÄ 5) Centered Start button, gated by checkbox ‚îÄ‚îÄ‚îÄ
    _, center, _ = st.columns([1,2,1])
    with center:
        if st.button("Start Symptom Check", disabled=not confirm):
            st.session_state.page = "user_info"
            st.rerun()

    # ‚îÄ‚îÄ‚îÄ 6) Footer ‚îÄ‚îÄ‚îÄ
    st.markdown("<div class='footer'>Powered by LexMedical Services LTD</div>", unsafe_allow_html=True)

    # ‚îÄ‚îÄ Hidden Admin Access (testing only) ‚îÄ‚îÄ
    pwd = st.sidebar.text_input("Dev code", type="password")
    if pwd == "Akinola":  # ‚Üê replace with your own secret
        st.sidebar.markdown("### Feature flags")
        st.sidebar.checkbox(
            "Enforce weak anchors",
            key="STRICT_WEAK_ANCHORS",
            value=st.session_state.get("STRICT_WEAK_ANCHORS", False),
            help="Generic tokens (pain/rash/fever) only count if overlapping a non-weak body part."
        )
        st.sidebar.checkbox(
            "Strict generic mode",
            key="STRICT_GENERIC_MODE",
            value=st.session_state.get("STRICT_GENERIC_MODE", False),
            help="For generic-only inputs, clamp primaries to hinted body parts or a generic‚Üídomain map."
        )

        if st.sidebar.button("View Analytics"):
            st.session_state.page = "analytics"
            st.rerun()

def user_info_page():
    st.image(logo, width=80)
    st.subheader("Before we begin, I‚Äôd like to know a little about you.")

    with st.form("user_info_form"):
        age = st.number_input("Age", min_value=0, max_value=120)
        # ‚Üê‚Äî THIS IS THE NEW ‚ÄúPediatric Mode‚Äù NOTE
        if 0 <= age <= 14:
            st.info("üë∂ Ages 0‚Ää‚Äì‚Ää14 will activate Pediatric mode on the next screen.")

        gender = st.radio("Gender", ["Male", "Female"], horizontal=True)
        conditions = st.text_input(
            "Existing conditions",
            placeholder="Mention any long-term health issues you live with (like asthma or none)"
        )

        submit_col, _ = st.columns([1, 2])
        with submit_col:
            cont = st.form_submit_button("Continue ‚Üí", type="primary")

    back_col, _ = st.columns([1, 2])
    with back_col:
        back = st.button("‚Üê Back")

    if back:
        st.session_state.page = "welcome"
        st.rerun()
    if cont:
        # ‚îÄ‚îÄ Save demographics ‚îÄ‚îÄ
        st.session_state.user_data['age']        = age
        st.session_state.user_data['gender']     = gender
        st.session_state.user_data['conditions'] = conditions

        # ‚îÄ‚îÄ 1) Pediatrics shortcut for ages 0‚Äì14 ‚îÄ‚îÄ
        if 0 <= age <= 14:
            # reset any free-text leftovers so source == db (has 'SubCategory')
            st.session_state.free_input_mode = False
            st.session_state.matched_conditions = pd.DataFrame()

            st.session_state.user_data['primary_category'] = "Pediatrics (Child Health)"
            st.session_state.page = "symptom_subcategory"
        else:
            # ‚îÄ‚îÄ Adult/other flow unchanged ‚îÄ‚îÄ
            st.session_state.page = "symptom_category"

        st.rerun()

def symptom_category_page():
    # ‚îÄ‚îÄ‚îÄ 0) Inject CSS for uniform, wrapped, full-width buttons ‚îÄ‚îÄ‚îÄ
    st.markdown(
        """<style>
          .stButton > button {
            width: 100% !important;
            white-space: normal !important;
            word-wrap: break-word !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            min-height: 4rem !important;
            padding: 0.75rem 1rem !important;
          }
        </style>""",
        unsafe_allow_html=True
    )

    # ‚îÄ‚îÄ‚îÄ 1) Logo & heading ‚îÄ‚îÄ‚îÄ
    st.image(logo, width=80)
    st.subheader("Let‚Äôs start with what‚Äôs bothering you today")

    # ‚îÄ‚îÄ‚îÄ 2) Gender guard ‚îÄ‚îÄ‚îÄ
    current_gender = st.session_state.user_data.get('gender')
    if not current_gender:
        st.error("Gender not selected. Please go back.")
        return
    
    # ‚îÄ‚îÄ‚îÄ 2b) Age-aware category list (hide Pediatrics for 15+) ‚îÄ‚îÄ‚îÄ
    current_age = st.session_state.user_data.get('age')

    valid_categories = []
    for cat in db["Primary Category"].unique():

        # Hide Pediatrics for ages 15+
        if (current_age is not None) and (current_age >= 15) and str(cat).strip().lower() == "pediatrics":
            continue
        if is_gender_allowed(cat, current_gender, suppress_error=True):
            valid_categories.append(cat)

    def _row_allowed_for_gender(row, gender: str) -> bool:
        """Return True if this DB row is appropriate for the user's gender."""
        if not gender:
            return True
        # Reuse your gate without UI messages
        try:
            if not is_gender_allowed(str(row.get("Condition","")), gender, suppress_error=True):
                return False
        except Exception:
            pass
        # Heuristic keywords across subcategory + condition + symptoms
        text = f"{row.get('SubCategory','')} {row.get('Condition','')} {row.get('Symptoms','')}".lower()
        male_terms   = ("male", "prostate", "penile", "testicular", "scrot", "ejacul", "erectile")
        female_terms = ("female", "vaginal", "vulva", "labia", "uterine", "cervic", "ovarian", "menstrual", "pregnan")
        if gender == "Female" and any(t in text for t in male_terms):
            return False
        if gender == "Male"   and any(t in text for t in female_terms):
            return False
        return True
   
    # ‚îÄ‚îÄ‚îÄ 3) Render your 3-col grid via display_grid ‚îÄ‚îÄ‚îÄ
    selected = display_grid(valid_categories, cols=3)

    # ‚îÄ‚îÄ‚îÄ 4) Handle a valid selection ‚îÄ‚îÄ‚îÄ
    if selected and is_gender_allowed(selected, current_gender):
        st.session_state.free_input_mode = False
        st.session_state.matched_conditions = pd.DataFrame()
        st.session_state.user_data['primary_category'] = selected
        st.session_state.page = "symptom_subcategory"
        st.rerun()

    # ‚îÄ‚îÄ‚îÄ 5) Free-text fallback ‚îÄ‚îÄ‚îÄ
    if st.button("Can‚Äôt find your symptoms? Enter them here"):
        st.session_state.page = "symptom_free_input"
        st.rerun()

    # ‚îÄ‚îÄ‚îÄ 6) Back button ‚îÄ‚îÄ‚îÄ
    if st.button("‚Üê Back"):
        st.session_state.page = "user_info"
        st.rerun()

def symptom_free_input_page():
    import re
    from collections import defaultdict
    import pandas as pd
    from datetime import datetime

    st.image(logo, width=80)
    st.subheader("What are your symptoms?")
    st.markdown("Use 1‚Äì2 simple symptoms. Separate multiple with commas (e.g., headache, fever, dizziness, leg pain)")

    # ---------- Local helpers (scoped to this function; safe to remove/move later) ----------
    def _ck_normalize(s: str) -> str:
        # keep commas/semicolons for phrase splits; letters/digits/spaces only
        return re.sub(r'\s+', ' ', re.sub(r'[^A-Za-z0-9\s,;]', ' ', str(s).lower())).strip()

    def _ck_tokenize(s: str):
        # tokens are words >=3 letters
        return re.findall(r"[A-Za-z]{3,}", str(s).lower())

    def _ck_stem(token: str) -> str:
        t = token.lower()
        # conservative suffix strip (single pass)
        for suff in ("ness", "ions", "ion", "ing", "ed", "es", "s"):
            if len(t) > 4 and t.endswith(suff):
                t = t[:-len(suff)]
                break
        # y -> i normalization (dizzy -> dizzi)
        if t.endswith("y") and len(t) >= 4:
            t = t[:-1] + "i"
        return t
    
    def _ck_detect_body_part_hints(free_text_norm: str):
        """Return a set of category labels hinted by body-part aliases in the input."""
        hints = set()
        s = f" {free_text_norm} "

        def _is_weak(a): return a in WEAK_ANCHORS

        # phrase-level detection (e.g., 'lower back'); skip weak anchors if flag is on
        for alias, cats in BP_ALIAS_TO_HINTS.items():
            if f" {alias} " in s:
                if st.session_state.get("STRICT_WEAK_ANCHORS", False) and _is_weak(alias):
                    continue
                hints |= cats

        # token-level detection; same skip rule
        for tok in set(_ck_tokenize(free_text_norm)):
            if st.session_state.get("STRICT_WEAK_ANCHORS", False) and tok in WEAK_ANCHORS:
                continue
            cats = BP_ALIAS_TO_HINTS.get(tok, set())
            hints |= cats
        return hints



    # Minimal curated synonyms (can be expanded later; not exhaustive by design)
    _CK_SYNONYMS = {
    # Skin
    "rash": {"rashes", "hives", "urticaria", "dermatitis", "exanthem", "eruption"},
    "itch": {"itchy", "itching", "pruritus"},

    # Neuro
    "dizziness": {"dizzy", "lightheaded", "lightheadedness", "giddiness"},
    "headache": {"migraine", "head pain"},

    # GI
    "stomach": {"belly", "tummy", "abdomen", "abdominal"},
    "bloating": {"gas", "gassy", "bloated"},
    "constipation": {"constipated"},
    "diarrhea": {"diarrhoea", "runny stool", "loose stool", "watery stool"},
    "vomit": {"vomiting", "emesis", "throwing up"},

    # Resp
    "breathlessness": {"shortness of breath", "sob", "dyspnea", "dyspnoea"},
    "phlegm": {"mucus", "sputum", "catarrh"},

    # GU
    "urinate": {"urination", "urinating", "pee", "peeing", "passing urine"},
    "burning": {"burning urination", "dysuria"},

    # Women‚Äôs health
    "period": {"menstruation", "menses", "menstrual", "cramps", "dysmenorrhea", "period pains"},
    "vaginal_discharge": {"vaginal discharge", "vag discharge"},
    }
    

    def _ck_variants(token: str):
        t = token.lower().strip()
        base = {t, _ck_stem(t)}
        infl = set()

        # add/remove simple inflections
        for suff in ("s", "es", "ed", "ing", "ion", "ions", "ness"):
            if t.endswith(suff) and len(t) > len(suff) + 2:
                infl.add(t[:-len(suff)])
            infl.add(t + suff)

        # y <-> i (dizzy -> dizzi)
        if t.endswith("y") and len(t) >= 4:
            infl.add(t[:-1] + "i")

        syn = _CK_SYNONYMS.get(t, set())

        out = base | infl | syn | {_ck_stem(x) for x in (infl | syn)}
        return {x for x in out if len(x) >= 3}

    def _ck_build_row_index(df, pri_col="Primary Category", sym_col="Symptoms"):
        rows = []
        for i, r in df.iterrows():
            cat = _ck_normalize(r.get(pri_col, ""))
            sym = _ck_normalize(r.get(sym_col, ""))
            cat_toks = set(_ck_tokenize(cat))
            sym_toks = set(_ck_tokenize(sym))
            rows.append({
                "idx": i,
                "cat": r.get(pri_col, ""),
                "sym": r.get(sym_col, ""),
                # include both raw token and stem for fast exact/stem checks
                "cat_tokens": set.union(cat_toks, {_ck_stem(t) for t in cat_toks}),
                "sym_tokens": set.union(sym_toks, {_ck_stem(t) for t in sym_toks}),
            })
        return rows

    def _ck_score_categories_and_subset(free_text, df, pri_col="Primary Category", sym_col="Symptoms"):
        # B2 ‚Äì part 1: split normalize & tokenize so we can reuse free_norm

        # Apply full phrase normalization (includes FreeTextMap + stop phrases)
        free_norm = normalize_free_text(free_text)

        tokens    = set(_ck_tokenize(free_norm))

        if not tokens:
            return [], df.iloc[0:0]

        # detect hinted categories from body-part aliases (needs _ck_detect_body_part_hints + BP_ALIAS_TO_HINTS)
        hint_boosts = _ck_detect_body_part_hints(free_norm)

        GENERIC_FLAT = set().union(*GENERIC_FAMILY.values())
        def _is_generic(tok: str) -> bool:
            return (tok in GENERIC_FLAT) or (_ck_stem(tok) in GENERIC_FLAT)
        non_generic = {t for t in tokens if not _is_generic(t)}
        generic_only = (len(non_generic) == 0)



        # Which generics are present in the input?
        present_generics = set()
        for g, fam in GENERIC_FAMILY.items():
            if any((t in fam) or (_ck_stem(t) in fam) for t in tokens):
                present_generics.add(g)

        # Union of allowed substrings for those generics (from GENERIC_TO_CATKEYS)
        dyn_allowed = set().union(*(GENERIC_TO_CATKEYS.get(g, set()) for g in present_generics))


        # Build body-part tokens from our alias map so plurals/phrases (e.g., "legs", "knees", "lower back")
        # are treated as first-class tokens. Keep simple side modifiers too.
        BODY_PART_TOKENS = set(BP_ALIAS_TO_HINTS.keys()) | {
            # explicit fallbacks (in case a term is missing from aliases)
            "head","scalp","face","eye","ear","nose","throat","neck","chest","breast","back",
            "shoulder","arm","elbow","forearm","wrist","hand","finger","hip","groin","abdomen","stomach",
            "belly","flank","waist","buttock","leg","thigh","knee","calf","shin","ankle","foot","toe",
            # weak/broad anchors (filtered when STRICT_WEAK_ANCHORS is True)
            "skin","body","area","surface","left","right","upper","lower","middle","central","lateral",
            "inner","outer"
        }

        # Include stems so "legs" matches "leg", "knees" ‚Üí "knee", etc.
        input_parts = {
            (_ck_stem(t) if _ck_stem(t) in BODY_PART_TOKENS else t)
            for t in tokens
            if (t in BODY_PART_TOKENS) or (_ck_stem(t) in BODY_PART_TOKENS)
        }

        token_variants = {t: (_ck_variants(t) | {t, _ck_stem(t)}) for t in tokens}
        rows = _ck_build_row_index(df, pri_col=pri_col, sym_col=sym_col)

        from collections import defaultdict
        rows_by_cat = defaultdict(list)
        for r in rows:
            rows_by_cat[r["cat"]].append(r)

        cat_stats = {}
        cat_rows_hit = defaultdict(set)

        # ---- Stage 1: category-name hits (plus body-part boost)
        for cat, rlist in rows_by_cat.items():
            cat_tokens_union = set()
            for r in rlist:
                cat_tokens_union |= r["cat_tokens"]

            cat_hits = 0
            for t in tokens:
                vset = token_variants[t]
                if any((v in cat_tokens_union) for v in vset):
                    cat_hits += 1

            # B2 ‚Äì part 2: apply hint boost
            if cat in hint_boosts:
                cat_hits += 1

            cat_stats[cat] = {"cat_hits": cat_hits, "sym_hits": 0}

        # ---- Stage 2: symptoms hits (unchanged)
        for cat, rlist in rows_by_cat.items():
            sym_hits = 0
            for r in rlist:
                sym_tokens = r["sym_tokens"]
                row_hit = False
                

                cat_tokens = r["cat_tokens"]
                # Consider stems from row text to catch forms like "knees", "hands", etc.
                row_terms  = (sym_tokens | cat_tokens) | {_ck_stem(x) for x in (sym_tokens | cat_tokens)}
                row_parts  = BODY_PART_TOKENS.intersection(row_terms)

                for t in tokens:
                    vset = token_variants[t]

                    if t in non_generic:
                        # Non-generic tokens may match exactly or with tight fuzzy
                        if any((v in sym_tokens) for v in vset):
                            row_hit = True
                            break
                        if any(ok_pair(t, s) for s in sym_tokens):
                            row_hit = True
                            break
                    else:
                        # Generic token (e.g., pain, rash, fever)
                        if any((v in sym_tokens) for v in vset):
                            row_ok = False

                            # If a body part was provided, require overlap (respect weak-anchor flag if ON)
                            if input_parts:
                                overlap = (row_parts & input_parts)
                                if st.session_state.get("STRICT_WEAK_ANCHORS", False):
                                    overlap = {p for p in overlap if p not in WEAK_ANCHORS}
                                if overlap:
                                    row_ok = True

                            # B - generic+hint fallback:
                            # If the user hinted this category via a body-part alias (e.g., "leg"),
                            # allow the generic hit (e.g., "pain") to count even if the row itself
                            # doesn't mention that body part explicitly.
                            if (not row_ok) and (cat in hint_boosts):
                                row_ok = True

                            # If NO body part (e.g., input normalized to "rash"),
                            # allow only when the category name is in the generic's domain
                            if not input_parts and dyn_allowed:
                                if any(k in _cat_norm(cat) for k in dyn_allowed):
                                    row_ok = True

                            if row_ok:
                                row_hit = True
                                break



                if row_hit:
                    sym_hits += 1
                    cat_rows_hit[cat].add(r["idx"])
            # Pairwise boost: reward rows that hit ‚â•2 user tokens
            pair_boost = 0
            if len(tokens) >= 2:
                for r in rlist:
                    sym_tokens = r["sym_tokens"]
                    hit_count = 0
                    for t in tokens:
                        vset = token_variants[t]
                        if any((v in sym_tokens) for v in vset):
                            hit_count += 1
                        if hit_count >= 2:
                            pair_boost += 1
                            break

            cat_stats[cat]["sym_hits"] = sym_hits + 0.5 * pair_boost

        # ---- scoring & selection (unchanged)
        ranking = []
        for cat, stv in cat_stats.items():
            score = 1.0 * stv["cat_hits"] + 2.0 * stv["sym_hits"]
            ranking.append((cat, score, stv["sym_hits"], len(cat_rows_hit[cat])))
        ranking.sort(key=lambda x: (x[1], x[2], x[3]), reverse=True)

        # must have ‚â•1 symptom hit; block category-only admits
        current_gender = st.session_state.user_data.get('gender')
        current_age = st.session_state.user_data.get('age')

        valid_cats = {
            cat for (cat, score, sym_hits, _n) in ranking
            if (sym_hits >= 1 and score >= 2.0)
                and not ((current_age is not None) and (current_age >= 15) and _cat_norm(cat) == "pediatrics")
                and is_gender_allowed(cat, current_gender, suppress_error=True)
        }

        # For generic-only inputs, tighten sensibly when the feature flag is ON
        if _flag("STRICT_GENERIC_MODE") and generic_only:
            # If the user gave a strong body part, clamp to hinted categories
            strong_parts = input_parts - WEAK_ANCHORS
            if strong_parts and hint_boosts:
                hinted = {cat for cat in valid_cats if cat in hint_boosts}
                if hinted:
                    valid_cats = hinted

            # If no strong body part, use a generic‚Üídomain whitelist
            if not strong_parts:
                present_generics = set()
                for g, fam in GENERIC_FAMILY.items():
                    if any((t in fam) or (_ck_stem(t) in fam) for t in tokens):
                        present_generics.add(g)

                dyn_allowed = set().union(*(GENERIC_TO_CATKEYS.get(g, set()) for g in present_generics)) or set()

                if dyn_allowed:
                    def _ok_cat(name: str) -> bool:
                        c = _cat_norm(name)
                        return any(k in c for k in dyn_allowed)
                    filtered = {cat for cat in valid_cats if _ok_cat(cat)}
                    if filtered:
                        valid_cats = filtered
        else:
            # Dynamic, generic-only gating (no flags) ‚Äî keep it narrow for the present generic(s)
            if generic_only and not hint_boosts:
                # Detect which generic families are present in the input
                present_generics = set()
                for g, fam in GENERIC_FAMILY.items():
                    if any((t in fam) or (_ck_stem(t) in fam) for t in tokens):
                        present_generics.add(g)

                # Build a narrow allowlist based on the generic(s)
                def _allow_keys_for_generic(g):
                    if g == "rash":
                        return {"skin","rash","dermat"}                      # dermatology only
                    if g == "pain":
                        return {"pain","discomfort","injury","bite","swelling"}
                    if g == "cough":
                        return {"breath","cough","respir"}
                    if g == "vomiting":
                        return {"stomach","digest","abdom"}
                    if g == "diarrhea":
                        return {"stomach","digest","abdom","rectal","bowel"}
                    if g == "dizziness":
                        return {"ear","nose","throat","head"}
                    if g in {"fatigue","weakness"}:
                        return {"gen","pain","discomfort"}
                    if g == "fever":
                        return {"breath","cough","respir","stomach","digest","abdom"}
                    return set()

                dyn_allowed = set().union(*(_allow_keys_for_generic(g) for g in present_generics))
                if dyn_allowed:
                    def _ok_cat(name: str) -> bool:
                        c = _cat_norm(name)
                        return any(k in c for k in dyn_allowed)
                    filtered = {cat for cat in valid_cats if _ok_cat(cat)}
                    if filtered:
                        valid_cats = filtered

        # persist flag so next screen can clamp to Top-3 (you already read this later)
        st.session_state.user_data["generic_only"] = bool(generic_only)

        # Keep only rows that actually matched the user‚Äôs tokens, not every row in the category
        match_ids = set()
        for cat in valid_cats:
            match_ids |= cat_rows_hit[cat]   # these are the row indices that got a symptom hit

        subset = df.loc[sorted(match_ids)] if match_ids else df.iloc[0:0]

        ordered_cats = [cat for (cat, score, sym_hits, _n) in ranking if cat in valid_cats]
        return ordered_cats, subset
    
        # ---------- End local helpers ----------

    # ‚Äî Wrap input & submit in a form so Enter works ‚Äî
    with st.form("free_input_form"):
        symptom_input = st.text_input("Your symptoms:")
        search = st.form_submit_button("Search Symptoms")

    if search:
        # ===== CK: Category-first free-text matching =====
        if not symptom_input.strip():
            st.warning("Please enter at least one symptom to search.")
            return

        # Use your DataFrame 'db' and expected columns
        ordered_cats, subset = _ck_score_categories_and_subset(symptom_input, db,
                                                               pri_col="Primary Category",
                                                               sym_col="Symptoms")

        if subset.empty or not ordered_cats:
            # Log and show the same UX actions as before
            try:
                log_failure({
                    "timestamp": datetime.utcnow().isoformat(),
                    "step":      "free_text_match_ck",
                    "input":     symptom_input,
                    "reason":    "no_symptom_match"
                })
            except Exception:
                pass

            st.warning("‚ùóÔ∏è ‚ÄúLet‚Äôs try that again. We couldn‚Äôt find a close match yet. Try one or two simple symptoms (e.g., rash, fever, cough) or pick a body area. You can also speak with a doctor.")
            if st.button("Try Again"):
                st.rerun()
            if st.button("Speak to a Doctor"):
                st.session_state.page = "fallback_page"
                st.rerun()
            if st.button("Start Over"):
                st.session_state.clear()
                st.session_state.page = "welcome"
                st.rerun()
            return

        # Success: save results & advance (retain UI/UX flow)
        st.session_state.free_input_mode            = True
        st.session_state.matched_conditions         = subset
        st.session_state.user_data['free_symptoms'] = symptom_input
        st.session_state.free_primary_ranking       = ordered_cats  # ordered by relevance score
        st.session_state.page                       = "symptom_primary_category_freeinput"
        st.rerun()
        # ===== End CK block =====

    # ‚Äî Back button outside the form ‚Äî
    if st.button("‚Üê Back"):
        st.session_state.page = "symptom_category"
        st.rerun()



def symptom_primary_category_freeinput_page():
    # ‚îÄ‚îÄ Guard: only allow free-text category pick when we actually have matches ‚îÄ‚îÄ
    if not st.session_state.get("free_input_mode") or st.session_state.matched_conditions.empty:
        # fall back to the normal category picker
        st.session_state.page = "symptom_category"
        st.rerun()

    st.image(logo, width=80)
    st.subheader("What feels closest to how you‚Äôre feeling?")

    # now safe: we know matched_conditions exists and has columns
    subset = st.session_state.matched_conditions
    current_gender = st.session_state.user_data.get('gender')
    current_age    = st.session_state.user_data.get('age')

    # --- STRICT dominance filter for generic-only queries ---
    generic_only = bool(st.session_state.user_data.get("generic_only"))
    if generic_only and not subset.empty:
        counts = subset["Primary Category"].value_counts()
        TOP_N = 3
        keep = counts.head(TOP_N).index
        subset = subset[subset["Primary Category"].isin(keep)]


    # Build primary category list in the scored order (not alphabetical)
    ranked = st.session_state.get("free_primary_ranking", [])
    ranked_set = set(ranked)

    # Fall back if ranking missing: preserve previous behavior (alphabetical of subset)
    fallback_order = [cat for cat in subset["Primary Category"].dropna().unique().tolist() if str(cat).strip()]
    ordered = [c for c in ranked if c in subset["Primary Category"].values] or sorted(fallback_order)

    primaries = []
    for cat in ordered:
        # Age/gender gating
        if (current_age is not None) and (current_age >= 15) and str(cat).strip().lower() == "pediatrics":
            continue
        if not is_gender_allowed(cat, current_gender, suppress_error=True):
            continue
        primaries.append(cat)
        

    if not primaries:
        st.warning("We found matches, but none are available for your selected gender/age.")
        if st.button("‚Üê Back"):
            st.session_state.page = "symptom_free_input"
            st.rerun()
        return

    choice = display_grid(primaries, cols=2)
    if choice:
        st.session_state.user_data['primary_category'] = choice
        st.session_state.page = "symptom_subcategory"
        st.rerun()

    if st.button("‚Üê Back"):
        # Back one step in the free-text flow
        st.session_state.page = "symptom_free_input"
        st.rerun()


def symptom_subcategory_page():
    st.image(logo, width=80)
    st.subheader("Let‚Äôs get a bit more specific")

    # ‚îÄ‚îÄ Ensure we have a primary category ‚îÄ‚îÄ
    primary = st.session_state.user_data.get("primary_category")
    if not primary:
        st.error("No category selected. Please start over.")
        if st.button("Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # ‚îÄ‚îÄ 3) Pediatric‚Äêmode banner ‚îÄ‚îÄ
    if primary == "Pediatrics (Child Health)":
        st.info("üß∏ Pediatric mode activated‚Äîthese subcategories are age-appropriate for 0‚Äì14 years.")

    # ‚îÄ‚îÄ Rest of your existing flow ‚îÄ‚îÄ
    source = (
        st.session_state.matched_conditions
        if st.session_state.get("free_input_mode", False)
        else db
    )
    filtered = source[source["Primary Category"] == primary]

    # Gender-aware row filtering before we build the subcategory list
    current_gender = st.session_state.user_data.get("gender")
    if current_gender:
        filtered = filtered[filtered.apply(lambda r: _row_allowed_for_gender(r, current_gender), axis=1)]

    # pick the data source for this page
    source = st.session_state.matched_conditions if st.session_state.get("free_input_mode", False) else db

    # --- tiny guard to avoid KeyError: fall back if the current source lacks SubCategory
    if source.empty or ("SubCategory" not in source.columns):
        source = db

    filtered = source[source["Primary Category"] == st.session_state.user_data['primary_category']]
    raw_subcats = sorted(filtered["SubCategory"].dropna().unique())


    # Build subcategories from remaining rows
    raw_subcats = sorted(filtered["SubCategory"].dropna().unique())

    # Belt-and-suspenders: hide explicitly gendered titles that don't match
    def _subcat_allowed(sc: str, gender: str) -> bool:
        if not gender:
            return True
        s = str(sc).lower()
        male_terms   = ("male", "prostate", "penile", "testicular", "scrot", "ejacul", "erectile")
        female_terms = ("female", "vaginal", "vulva", "labia", "uterine", "cervic", "ovarian", "menstrual", "pregnan")
        if gender == "Female" and any(t in s for t in male_terms):   return False
        if gender == "Male"   and any(t in s for t in female_terms): return False
        return True

    subcats = [sc for sc in raw_subcats if _subcat_allowed(sc, current_gender)]

    choice = display_grid(subcats, cols=2)

    if choice:
        st.session_state.user_data["subcategory"] = choice
        st.session_state.current_condition = filtered[filtered["SubCategory"] == choice].iloc[0]
        st.session_state.page = "symptom_selection"
        st.rerun()

    if st.button("‚Üê Back"):
        st.session_state.page = (
            "symptom_primary_category_freeinput"
            if st.session_state.get("free_input_mode", False)
            else "symptom_category"
        )
        st.rerun()

def symptom_selection_page():
    st.image(logo, width=80)
    st.subheader("Tell me about your symptoms")

    primary = st.session_state.user_data.get("primary_category")
    subcat  = st.session_state.user_data.get("subcategory")
    if not primary or not subcat:
        st.error("Category or subcategory missing. Please start over.")
        if st.button("Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # 1) Decide source: full DB for normal, matched_conditions for free-text
    source = st.session_state.matched_conditions if st.session_state.get("free_input_mode") else db

    # 2) Filter to your chosen subcategory
    subset = source[
        (source["Primary Category"] == primary) &
        (source["SubCategory"]      == subcat)
    ]

    # Gender-aware row filtering (row-level, not just titles)
    gender = st.session_state.user_data.get("gender")
    if gender:
        subset = subset[subset.apply(lambda r: _row_allowed_for_gender(r, gender), axis=1)]
    if subset.empty:
        st.error("No conditions found here‚Äîplease go back and choose another subcategory.")
        if st.button("‚Üê Back"):
            st.session_state.page = "symptom_subcategory"
            st.rerun()
        return

    # 3) Aggregate **all** symptoms across those rows
    options = sorted({
        s.strip()
        for row in subset["Symptoms"].dropna()
        for s   in row.split(",")
    })

    # 4) Render them
    selected = st.multiselect("Select all that apply:", options)

    # 5) Navigation
    col1, col2 = st.columns([1,3])
    with col1:
        if st.button("‚Üê Back"):
            st.session_state.page = "symptom_subcategory"
            st.rerun()
    with col2:
        if st.button("Continue ‚Üí"):
            st.session_state.user_data['selected_symptoms'] = selected
            st.session_state.page = "clarifying_questions"
            st.rerun()

def clarifying_questions_page():
    st.image(logo, width=80)
    st.subheader("Just a couple more quick questions to guide you")

    # 1Ô∏è‚É£ Build the subset of rows for this pathway
    primary = st.session_state.user_data.get("primary_category")
    subcat  = st.session_state.user_data.get("subcategory")

    # pick source: full DB if normal, else your matched free-text subset
    source = db if not st.session_state.get("free_input_mode", False) else st.session_state.matched_conditions

    # filter to the chosen primary/subcategory
    subset = source[
        (source["Primary Category"] == primary) &
        (source["SubCategory"]      == subcat)
    ]
    if subset.empty:
        st.error("No conditions found here‚Äîplease start over.")
        if st.button("Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # 2Ô∏è‚É£ Stage 1: ask every unique CQ1 in this subset
    if not st.session_state.get("cq1_done"):
        cq1s    = list(subset["Clarifying Questions 1"].dropna().unique())
        answers1 = {}
        with st.form("cq1_form"):
            for i, q in enumerate(cq1s, 1):
                ans = st.radio(q, ["Yes", "No"], key=f"cq1_{i}")
                answers1[q] = ans
                answers1[f"cq1_{i}"] = ans   # NEW: store numbered key
            # summary flag for the whole stage
            answers1["cq1"] = "Yes" if any(v == "Yes" for k, v in answers1.items() if k.startswith("cq1_")) else "No"

            if st.form_submit_button("Continue ‚Üí"):
                st.session_state.user_data["answers1"] = answers1
                st.session_state.cq1_done = True
                st.rerun()

        # Back takes you up one step (category or free-text)
        if st.button("‚Üê Back"):
            st.session_state.page = (
                "symptom_primary_category_freeinput"
                if st.session_state.get("free_input_mode", False)
                else "symptom_subcategory"
            )
            st.rerun()
        return

    # 3Ô∏è‚É£ Stage 2: only if any CQ1 was ‚ÄúYes‚Äù
    answers1 = st.session_state.user_data.get("answers1", {})
    if any(v == "Yes" for v in answers1.values()):
        cq2s     = list(subset["Clarifying Questions2"].dropna().unique())
        answers2 = {}
        with st.form("cq2_form"):
            for j, q in enumerate(cq2s, 1):
                ans = st.radio(q, ["Yes", "No"], key=f"cq2_{j}")
                answers2[q] = ans
                answers2[f"cq2_{j}"] = ans   # NEW: store numbered key
            # summary flag for the whole stage
            answers2["cq2"] = "Yes" if any(v == "Yes" for k, v in answers2.items() if k.startswith("cq2_")) else "No"

            if st.form_submit_button("Continue ‚Üí"):
                merged = {**answers1, **answers2}
                st.session_state.user_data["clarifying_answers"] = merged
                st.session_state.page = "risk_flag_selection"
                del st.session_state.cq1_done
                st.rerun()

        # Back goes back into Stage 1
        if st.button("‚Üê Back"):
            del st.session_state.cq1_done
            st.rerun()
        return

    # 4Ô∏è‚É£ No ‚ÄúYes‚Äù in CQ1: skip straight to risk flags
    st.session_state.user_data["clarifying_answers"] = answers1
    del st.session_state.cq1_done
    st.session_state.page = "risk_flag_selection"
    st.rerun()

# Helper: Show "No Match" message and safe next steps
def show_no_match_ui():
    # New heading for this screen
    st.subheader("...Unfortunately, we haven‚Äôt found a match yet.")

    # Explanatory message
    st.markdown(
    """
    <div style="
        background:#fff3cd;
        border:1px solid #ffeeba;
        color:#664d03;
        border-radius:10px;
        padding:16px 18px;
        margin:8px 0 14px;
        font-size:1.15rem;   /* ‚Üë increase size */
        font-weight:700;     /* ‚Üë bold */
        line-height:1.5;
    ">
      I couldn‚Äôt confidently match your answers to a condition in this section.
      You can Schedule a Consultation or start over and try a different path.
    </div>
    """,
    unsafe_allow_html=True,
)

    # CTAs
    col1, col2 = st.columns(2)
    with col1:
        if st.button("üìÖGet help/Schedule a Consultation", use_container_width=True):
            # TODO: swap this info() with your scheduling flow when ready
            st.info("Appointment scheduling flow will be implemented here.")
    with col2:
        if st.button("üîÑ Start Over", use_container_width=True):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()

    # Small safety reminder
    st.markdown(
        "<div style='font-size:1.05rem; font-weight:700; color:#6b7280; margin-top:8px;'>"
        "‚ö†Ô∏è If symptoms worsen or red flags appear, seek urgent care."
        "</div>",
        unsafe_allow_html=True,
    )

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


def risk_flag_selection_page():
    st.image(logo, width=80)
    #st.subheader("These factors can affect your care. Select any that apply, or ‚ÄúNone.‚Äù")

    # ‚îÄ‚îÄ 1) Build the subset of candidate conditions ‚îÄ‚îÄ
    cat    = st.session_state.user_data.get("primary_category")
    sub    = st.session_state.user_data.get("subcategory")
    source = (
        st.session_state.matched_conditions
        if st.session_state.get("free_input_mode", False)
        else db
    )
    subset = source[
        (source["Primary Category"] == cat) &
        (source["SubCategory"]      == sub)
    ]
    if subset.empty:
        st.error("No conditions found here‚Äîplease start over.")
        return
    
    # Clear any stale risk selections before evaluating rules
    st.session_state.user_data["confirmed_risks"] = []
    
    # 3Ô∏è‚É£ Prefer rows whose Labeling Rule passes for this user
    subset = subset.copy()
    
    def _passes(row):
        return evaluate_rule(row.get("Labeling Rule",""), row, st.session_state.user_data, phase="selection")

    subset["rule_ok"] = subset.apply(_passes, axis=1)
    candidates = subset[subset["rule_ok"]]

    if candidates.empty:
        # show the new heading here (and the CTAs in the helper)
        #st.subheader("Unfortunately, we haven‚Äôt found a match yet.")
        show_no_match_ui()
        return
    else:
        st.subheader("These factors can affect your care. Select any that apply, or ‚ÄúNone.‚Äù")
        subset = candidates

    # HARD-GATE: do not fall back to the original subset if empty
    if candidates.empty:
        show_no_match_ui()
        return
    else:
        subset = candidates

    # (Optional) Skip "Low" confidence rows entirely; remove this block if you prefer to keep them
    subset = subset[subset["Labeling Confidence"].str.lower().ne("low")]
    if subset.empty:
        show_no_match_ui()
        return

    # Ranking function used for tie-breaks

    
    def _rank_key(r):
        conf = str(r.get("Labeling Confidence", "Low")).lower()
        conf_rank = {"high": 2, "medium": 1, "low": 0}.get(conf, 0)
        acu = int(r.get("Acuity Level", 1) or 1)
        rule_len = len(str(r.get("Labeling Rule", "")))
        name = str(r.get("Condition", ""))
        # Sort: higher confidence, higher acuity, shorter rule, A‚ÜíZ
        return (-conf_rank, -acu, rule_len, name)

    # Sort by a single helper column that holds the tuple (lexicographic order)
    subset = (
        subset
        .assign(__rk=subset.apply(_rank_key, axis=1))
        .sort_values("__rk", ascending=True)
        .drop(columns="__rk")
    )

    # ‚îÄ‚îÄ 2) Map CQ2 ‚ÄúYes‚Äù answers back to rows ‚îÄ‚îÄ
    answers = st.session_state.user_data.get("clarifying_answers", {})
    flagged = []
    for idx, row in subset.iterrows():
        q2 = row["Clarifying Questions2"]
        if pd.notna(q2) and answers.get(q2) == "Yes":
            flagged.append(idx)

    # ‚îÄ‚îÄ 3) Triaging logic, always run ‚îÄ‚îÄ
    if len(flagged) == 1:
        chosen_idx = flagged[0]
    elif len(flagged) > 1:
        # Apply the same ranking only within the flagged set
        df_flagged = subset.loc[flagged].copy()
        df_flagged = (
            df_flagged
            .assign(__rk=df_flagged.apply(_rank_key, axis=1))
            .sort_values("__rk", ascending=True)
        )
        chosen_idx = df_flagged.index[0]
    else:
        # No CQ2 flags ‚Üí pick the top-ranked candidate overall
        subset_ranked = (
            subset
            .assign(__rk=subset.apply(_rank_key, axis=1))
            .sort_values("__rk", ascending=True)
        )
        chosen_idx = subset_ranked.index[0]

    # ‚îÄ‚îÄ 4) Save the final condition ‚îÄ‚îÄ
    st.session_state.current_condition = subset.loc[chosen_idx]

    # ‚îÄ‚îÄ 5) Render its RiskFlags ‚îÄ‚îÄ
    cond = st.session_state.current_condition
    raw = str(cond.get("RiskFlags", "") or "")
    flags = [f.strip() for f in raw.split(",") if f.strip()]

    selected = []
    for flag in flags:
        if st.checkbox(flag, key=f"rf_{flag}"):
            selected.append(flag)

    none = st.checkbox("None / Not Applicable", key="rf_none")
    if none and selected:
        st.warning("‚ÄúNone‚Äù cannot be combined with other selections; only ‚ÄúNone‚Äù will be used.")

    # ‚îÄ‚îÄ 6) Continue ‚Üí record and go to Results ‚îÄ‚îÄ
    if st.button("Continue"):
        st.session_state.user_data["confirmed_risks"] = [] if none else selected
        st.session_state.page = "results"
        st.rerun()

    # ‚Üê Back ‚Üí clarifiers
    if st.button("‚Üê Back"):
        st.session_state.page = "clarifying_questions"
        st.rerun()



import re

# REPLACE your evaluate_rule with this
def evaluate_rule(rule_str: str, condition: dict, user_data: dict, *, phase: str = "selection") -> bool:
    """
    Evaluate Labeling Rule against the user's inputs.
    phase="selection": ignore risk_flag atoms so valid rows aren't blocked pre-pick
    phase="results":   enforce risk_flag atoms normally
    """
    import re

    sel_syms = {s.strip().lower() for s in user_data.get("selected_symptoms", []) if isinstance(s, str)}
    sel_rfs  = {r.strip().lower() for r in user_data.get("confirmed_risks", []) if isinstance(r, str)}
    answers  = {str(k).lower(): str(v).strip().lower()
                for k, v in user_data.get("clarifying_answers", {}).items()}

    cq1_any = any((k.startswith("cq1_") and v == "yes") for k, v in answers.items())
    cq2_any = any((k.startswith("cq2_") and v == "yes") for k, v in answers.items())
    answers["cq1"] = "yes" if cq1_any else "no"
    answers["cq2"] = "yes" if cq2_any else "no"

    def eval_atom(atom: str) -> bool:
        atom = atom.strip()
        m = re.match(r"^symptom\s*==\s*(.+)$", atom, re.IGNORECASE)
        if m:
            return m.group(1).strip().lower() in sel_syms
        m = re.match(r"^risk_flag\s*==\s*(.+)$", atom, re.IGNORECASE)
        if m:
            v = m.group(1).strip().lower()
            return True if phase == "selection" else (v in sel_rfs)
        m = re.match(r"^cq(\d+)\s*==\s*yes$", atom, re.IGNORECASE)
        if m:
            n = m.group(1)
            if answers.get(f"cq{n}", "") == "yes":
                return True
            return any(k.startswith(f"cq{n}_") and v == "yes" for k, v in answers.items())
        return False

    parts = re.split(r"(\bAND\b|\bOR\b|\(|\))", str(rule_str or ""), flags=re.IGNORECASE)
    expr = ""
    for t in parts:
        t = t.strip()
        if not t: continue
        if re.fullmatch(r"AND", t, re.IGNORECASE):
            expr += " and "
        elif re.fullmatch(r"OR", t, re.IGNORECASE):
            expr += " or "
        elif t in ("(", ")"):
            expr += t
        else:
            expr += str(eval_atom(t))
    try:
        return bool(eval(expr)) if expr else False
    except Exception:
        return False



def make_recommendation(condition: dict, user_flags: dict, risk_flags: list) -> str:
    # Determine escalation
    acuity = condition.get("Acuity Level", 0)
    is_esc = bool(risk_flags) or (acuity == 3)

    # Confidence guard
    conf = condition.get("Labeling Confidence", "Low")
    if conf == "Low":
        return ""

    # Rule match guard (allow escalation)
    rule_ok = evaluate_rule(condition["Labeling Rule"], condition, st.session_state.user_data, phase="results")


    # ‚¨Ö NEW: enforce rule before building recommendation
    if not rule_ok and not is_esc:
        return ""

    # Certainty phrase
    certainty = "very likely" if conf == "High" else "symptoms suggest"

    # Pick templates
    if is_esc:
        base_tmpl = condition.get("Escalated Narrative Template (Risk Flags Present)", "")
        rec_text = condition.get("Escalated Recommendation", "")
    else:
        base_tmpl = condition.get("Default Narrative Template", "")
        rec_text = condition.get("Default Recommendation", "")

    # Render base with placeholders
    base = base_tmpl.format(
        certainty=certainty,
        risk_flags=", ".join(risk_flags),
        default_rec=condition.get("Default Recommendation", ""),
        escalated_rec=condition.get("Escalated Recommendation", "")
    )

    # Build recommendation without duplication
    if ('{default_rec}' in base_tmpl) or ('{escalated_rec}' in base_tmpl):
        recommendation = base
    else:
        recommendation = f"{base} {rec_text}".strip()

     #Append emergency note marker
    note = condition.get("Emergency (Time-critical) Narrative (If Applicable)", "").strip()
    if note:
        recommendation += f"\n\nüö® Important: {note}"

    return recommendation


def results_page():
    # Header and Title
    st.image(logo, width=80)
    #st.header("Based on your answers, your likely condition is:")

    # Fetch the chosen condition
    condition = st.session_state.current_condition
    if condition is None:
        st.error("No condition selected. Please start over.")
        if st.button("üîÑ Start New Check"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # Show the condition's name
    #condition_title = condition.get("Condition", "")
    #st.subheader(condition_title)

    # Determine baseline acuity (for card color)
    if st.session_state.get("free_input_mode"):
        baseline_rank = int(st.session_state.matched_conditions.get("Acuity Level", 0).max())
    else:
        baseline_rank = int(condition.get("Acuity Level", 0) or 0)

    # Gather & sanitize risk flags (avoid accidental truthy [""])
    raw_flags  = st.session_state.user_data.get("confirmed_risks", [])
    risk_flags = [rf.strip() for rf in raw_flags if isinstance(rf, str) and rf.strip()]

    # ‚Äî‚Äî‚Äî Assemble user_flags with normalized keys ‚Äî‚Äî‚Äî
    user_data  = st.session_state.user_data
    user_flags = {}

    # 1) Symptoms from selected_symptom
    for sym in user_data.get("selected_symptoms", []):
        key = sym.strip().lower().replace(" ", "_")
        user_flags[key] = True

    # 2) Clarifiers from clarifying_answers
    for question, ans in user_data.get("clarifying_answers", {}).items():
        if ans == "Yes":
            key = question.strip().lower().replace(" ", "_")
            user_flags[key] = True

    # 3) Risk flags
    for rf in risk_flags:
        key = rf.strip().lower().replace(" ", "_")
        user_flags[key] = True

    # Generate recommendation (string may include an appended emergency line in older builds)
    recommendation = make_recommendation(condition, user_flags, risk_flags)

    if recommendation:
        # ‚úÖ Only show headline when recommendation exists
        st.header("Based on your answers, your likely condition is:")

        # ‚¨áÔ∏è Move these two lines here
        condition_title = condition.get("Condition", "")
        st.subheader(condition_title)
    
    else:
        fallback_html = """
        <div style="
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            border-radius: 12px;
            padding: 24px;
            font-size: 1.25rem;
            line-height: 1.6;
            color: #3a2e00;
            font-weight: 500;
            text-align: center;
        ">
            I couldn‚Äôt make a confident match for your symptoms.<br>
            That happens sometimes, and it simply means a human touch is needed.<br>
            <strong>Consider reaching out to a healthcare professional ‚Äî or you can try another check with more details.</strong>
        </div>
        """
        st.markdown(fallback_html, unsafe_allow_html=True)

        # Add space before buttons
        st.markdown("<div style='margin-top: 20px;'></div>", unsafe_allow_html=True)

        col1, col2 = st.columns(2)
        with col1:
            if st.button("üîÑ Start Over", use_container_width=True):
                st.session_state.clear()
                st.session_state.page = "welcome"
                st.rerun()
        with col2:
            if st.button("üìÖ Schedule a Consultation", use_container_width=True):
                st.info("Appointment scheduling flow will be implemented here.")
        return

    # Display recommendation or fallback with styled blocks
    if recommendation:
        # Your escalation rule for card color:
        is_esc = (baseline_rank == 3) or bool(risk_flags)
        block_class = "report-block" if is_esc else "report-block report-block--ok"

        # If the recommendation string contains an appended emergency line,
        # strip it from the main text to avoid duplication (we render emergency separately).
        parts = recommendation.split('\n\nüö® Important: ')
        main_text = parts[0].strip()

        # MAIN CARD (escape DB content)
        safe_main = html.escape(main_text).replace('\n','<br>')
        card_html = (
            f"<div class='{block_class}' style='font-size: 1.2rem;'>"
            f"{safe_main}"
            "</div>"
        )

        

        st.markdown(card_html, unsafe_allow_html=True)

        # EMERGENCY NOTE ‚Äî render once, as a separate block
        emergency = (condition.get("Emergency Narrative (If Applicable)", "") or "").strip()
        if emergency:
            st.markdown(
                f"<div class='emergency-block' style='font-size: 1.2rem; margin-bottom: 20px;'>"
                f"üö® Important: {html.escape(emergency)}</div>",
                unsafe_allow_html=True
        )

        # Optional referral line below the card (escape too)
        ref_text = (condition.get("Referral", "") or "").strip()
        if ref_text:
            st.markdown(
                f"<div class='referral-block' style='font-size: 1.1rem; margin: 6px 0 18px;'>"
                f"ü©∫ <strong>{html.escape(ref_text)}</strong></div>",
                unsafe_allow_html=True
            )

    else:
        # Fallback amber (mobile-friendly)
        warn_html = (
            "<div class='report-block report-block--warn'>"
            "I‚Äôm not able to match a condition confidently. Please consider consulting a "
            "healthcare professional for a definitive evaluation."
            "</div>"
        )
        st.markdown(warn_html, unsafe_allow_html=True)

    # Optional: Schedule Appointment button
    if condition.get("Referral") and st.button("üìÖ Schedule a Consultation or Get Help"):
        st.info("Appointment scheduling will be available soon.")

    # Download report & New Check buttons (single set; CSS centers on mobile only)
    col1, col2 = st.columns([1, 1])

    with col1:
        report_text = generate_report()
        st.download_button(
            label="üìÑ Download Full Report",
            data=report_text,
            file_name=f"{condition_title}_report.txt",
            key="dl_report"
        )

    with col2:
        if st.button("üîÑ Start New Check", key="newcheck"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()

   # ‚¨áÔ∏è CSS comes immediately after these buttons
    st.markdown("""
    <style>
    @media (max-width: 640px) {
      /* Center the download button itself */
      div[data-testid="stDownloadButton"] > button {
        display: block !important;
        margin-left: auto !important;
        margin-right: auto !important;
      }
    }
    </style>
    """, unsafe_allow_html=True)



def fallback_page():
    st.image(logo, width=80)
    st.warning("I couldn‚Äôt find a clear match for your symptoms, which could mean they‚Äôre mild or need professional evaluation.")
    st.markdown("**Would you like to speak with a Doctor about this?**")
    col1, col2, col3 = st.columns([1,1,1])
    with col1:
        if st.button("üìÖ Schedule a Consultation"):
            st.info("Appointment scheduling flow will be implemented here.")
    with col2:
        if st.button("üîÑ Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
    with col3:
        if st.button("‚Üê Back"):
            st.session_state.page = "clarifying_questions"
            st.rerun()

PAGES = {
    "welcome": welcome_page,
    "user_info": user_info_page,
    "symptom_category": symptom_category_page,
    "symptom_free_input": symptom_free_input_page,
    "symptom_primary_category_freeinput": symptom_primary_category_freeinput_page,
    "symptom_subcategory": symptom_subcategory_page,
    "symptom_selection": symptom_selection_page,
    "clarifying_questions": clarifying_questions_page,
    "risk_flag_selection": risk_flag_selection_page,
    "results": results_page,
    "fallback_page": fallback_page,
    "analytics": analytics_page,
}
# ---- Auth gate: show login until authenticated ----
if not st.session_state.get("logged_in", False):
    login_page()
    st.stop()

PAGES[st.session_state.page]()