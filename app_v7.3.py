# -*- coding: utf-8 -*-
"""App_v5.5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E0X9U1nI-2YPh5tNkrh-K8g3lFZhDf9L
"""

import streamlit as st
import pandas as pd
from PIL import Image
import re
from difflib import SequenceMatcher
import os
import csv
from datetime import datetime
import html



LOG_PATH = "failure_log.csv"

GENERIC_TOKENS = {"pain", "ache", "aches", "soreness", "discomfort",
                  "rash", "rashes", "fever", "cough", "vomiting",
                  "diarrhea", "dizziness", "fatigue", "weakness"}

# New: treat “tenderness” as a generic synonym so “breast pain” ≈ “breast tenderness”
GENERIC_SYNONYMS = {"pain", "ache", "aches", "soreness", "discomfort", "tenderness",
                    "rash", "rashes", "fever", "cough", "vomiting",
                    "diarrhea", "dizziness", "fatigue", "weakness"}

GENERIC_SYNONYMS |= {"hives","urticaria","exanthem","dermatitis","eruption","itch","itchy","itching","pruritus"}

# Map each generic to common synonyms seen in the DB
GENERIC_FAMILY = {
    "pain": {"pain","ache","aches","soreness","discomfort","tenderness","cramp","cramps","spasm","spasms"},
    "rash": {"rash","rashes","hives","urticaria","exanthem","dermatitis","eruption"},
    "fever": {"fever","pyrexia","temperature"},
    "cough": {"cough","coughing"},
    "vomiting": {"vomiting","vomit","emesis","throwing","throwing up"},
    "diarrhea": {"diarrhea","diarrhoea","loose","watery","stools","stool"},
    "dizziness": {"dizziness","vertigo","lightheadedness"},
    "fatigue": {"fatigue","tiredness","malaise"},
    "weakness": {"weakness","asthenia"},
    
}

# Kill-switch for enforcing weak anchors (defaults OFF)
STRICT_WEAK_ANCHORS = st.session_state.get("STRICT_WEAK_ANCHORS", False)

if 'STRICT_WEAK_ANCHORS' not in st.session_state:
    st.session_state["STRICT_WEAK_ANCHORS"] = True


WEAK_ANCHORS = {"skin", "body", "area", "surface", "left","right","upper","lower","middle","central","lateral",
    "inner","outer"}

# --- Feature-flag safe defaults and tiny helper ---
if "STRICT_GENERIC_MODE" not in st.session_state:
    st.session_state["STRICT_GENERIC_MODE"] = False

def _flag(name: str) -> bool:
    return bool(st.session_state.get(name, False))

def _flag(name: str) -> bool:
    return bool(st.session_state.get(name, False))

# --- Category → keyword mapper (helps GENERIC gating pick up Toxicology/Poison/Exposure) ---
def _cat_to_key(cat: str) -> set[str]:
    """Turn 'Toxicology (Poison/Exposure)' → {'toxic','poison','exposure','toxicology'}."""
    import re
    t = (cat or "").lower()
    parts = [p for p in re.split(r"[^a-z]+", t) if p]
    keys = set(parts)
    if "toxicology" in keys or "toxic" in keys:
        keys.update({"toxic","toxicology"})
    return keys

# --- Generic → primary-category keywords (broad domains) ---
GENERIC_TO_CATKEYS = {
    "pain":     {"pain","discomfort","injury","bite","swelling"},
    "rash":     {"skin","rash","dermat"},
    "cough":    {"breath","cough","respir"},
    "vomiting": {"stomach","digest","abdom"},
    "diarrhea": {"stomach","digest","abdom","rectal","bowel"},
    "dizziness":{"ear","nose","throat","head"},
    "fatigue":  {"gen","pain","discomfort","respir","sleep","mental","infect",
                 "neuro","abdom","gastro","urination","thirst","toxic","poison","exposure"},
    "weakness": {"gen","pain","discomfort","respir","sleep","mental","infect",
                 "neuro","abdom","gastro","urination","thirst","toxic","poison","exposure"},
    "fever":    {"breath","cough","respir","stomach","digest","abdom"},
    "tired":    {"gen","pain","discomfort","respir","sleep","mental","infect",
                 "neuro","abdom","gastro","urination","thirst","toxic","poison","exposure"},
}


def log_failure(record: dict):
    file_exists = os.path.isfile(LOG_PATH)
    with open(LOG_PATH, "a", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=list(record.keys()))
        if not file_exists:
            writer.writeheader()
        writer.writerow(record)

def analytics_page():
    st.header("📊 App Failure Report")
    if not os.path.isfile(LOG_PATH):
        st.info("No failures logged yet.")
        return

    df = pd.read_csv(LOG_PATH, parse_dates=["timestamp"])
    st.subheader("Recent Failures")
    st.dataframe(df.sort_values("timestamp", ascending=False).head(20))

    st.subheader("Failures by Reason")
    counts = df["reason"].value_counts().reset_index()
    counts.columns = ["Reason","Count"]
    st.table(counts)

    st.subheader("Suggested FreeTextMap Additions")
    sugg = suggest_freetext_mappings(db, top_n=30)
    if not sugg.empty:
        st.dataframe(sugg)



def suggest_freetext_mappings(db, top_n=20):
    vocab = set()
    for s in db["Symptoms"].dropna().astype(str).tolist():
        for tok in re.findall(r"[A-Za-z]{3,}", s.lower()):
            vocab.add(tok)

    if not os.path.isfile(LOG_PATH):
        return pd.DataFrame()

    df = pd.read_csv(LOG_PATH)
    misses = df[df["reason"] == "no_symptom_match"]["input"].str.lower().value_counts().head(top_n)
    suggestions = []
    for phrase, cnt in misses.items():
        toks = re.findall(r"[A-Za-z]{3,}", phrase)
        nearest = []
        for t in toks:
            best = max(vocab, key=lambda v: SequenceMatcher(None, t, v).ratio(), default=None)
            if best:
                nearest.append((t, best))
        suggestions.append({"input_phrase": phrase, "count": cnt, "nearest_tokens": nearest})
    return pd.DataFrame(suggestions)

def stem(word: str) -> str:
    w = word.lower().strip()
    for suf in ("ing", "ion", "ed", "s", "ness", "able"):
        if w.endswith(suf):
            return w[: -len(suf)]
    return w

st.set_page_config(page_title="LEXY... LexMedical AI Triage System", page_icon="🩺", layout="centered")


# --- Mobile-friendly, high-contrast styles ---
st.markdown("""
<style>
.report-block {
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 10px;
  padding: 16px;
  font-size: 1rem;
  line-height: 1.6;
  color: #2b0000;
  word-wrap: break-word;
  overflow-wrap: anywhere;
}
.report-block--ok {
  background-color: #d4edda;
  border-color: #c3e6cb;
  color: #062b0a;
}            
.report-block--warn {
  background-color: #fff3cd;
  border: 1px solid #ffeeba;
  color: #3a2e00;
}
.emergency-block {
  margin-top: 16px;
  padding: 14px;
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 10px;
  font-weight: 600;
  font-size: 1rem;
  line-height: 1.6;
  color: #2b0000;
  word-wrap: break-word;
  overflow-wrap: anywhere;
}
@media (max-width: 640px) {
  .report-block, .emergency-block {
    font-size: 1.05rem;
    line-height: 1.7;
    padding: 18px;
  }
  .stButton > button { width: 100% !important; }
}
</style>
""", unsafe_allow_html=True)

# Initialize session state safely
if 'free_input_mode' not in st.session_state:
    st.session_state.free_input_mode = False
if 'page' not in st.session_state:
    st.session_state.page = "welcome"
if 'user_data' not in st.session_state:
    st.session_state.user_data = {}
if 'current_condition' not in st.session_state:
    st.session_state.current_condition = None
if 'confirmed_risks' not in st.session_state:
    st.session_state.confirmed_risks = []
if 'matched_conditions' not in st.session_state:
    st.session_state.matched_conditions = pd.DataFrame()
if 'logged_in' not in st.session_state:
    st.session_state.logged_in = False

@st.cache_data(ttl=60)
def load_data():
    df = pd.read_excel("SymptomBotDB.xlsx")
    df.columns = df.columns.astype(str).str.replace("\u00A0"," ", regex=False).str.strip()
    # ── Normalize every header: remove leading/trailing whitespace ──
    df.columns = df.columns.str.strip()
    return df
# --- Free-text normalization driven by Excel (FreeTextMap sheet) ---

@st.cache_data(ttl=60)
def load_freetext_map() -> dict:
    """
    Reads SymptomBotDB.xlsx -> sheet 'FreeTextMap' with columns:
      from_phrase, to_phrase  (case-insensitive)
    Returns dict {from_phrase_lower: to_phrase_lower}.
    If the sheet is missing, returns {} (no-op).
    """
    try:
        df_map = pd.read_excel("SymptomBotDB.xlsx", sheet_name="FreeTextMap")
        df_map.columns = df_map.columns.str.strip().str.lower()
        if not {"from_phrase","to_phrase"}.issubset(df_map.columns):
            return {}
        # build lowercase map, drop blanks
        m = {}
        for _, r in df_map.iterrows():
            fp = str(r["from_phrase"]).strip().lower()
            tp = str(r["to_phrase"]).strip().lower()
            if fp and tp and fp != "nan" and tp != "nan":
                m[fp] = tp
        return m
    except Exception:
        return {}

FT_MAP = load_freetext_map()

# c) fuzzy-stem match across token pairs (safer)
def ok_pair(us, ds):
    if len(us) < 4 or len(ds) < 4:
        return False
    if not (us[0] == ds[0] or us in ds or ds in us):
        return False

    # adaptive threshold
    base = 0.80
    if len(us) >= 6 and len(ds) >= 6:
        base = 0.74  # allow one typo on long words
    return SequenceMatcher(None, us, ds).ratio() >= base


def normalize_free_text(raw: str) -> str:
    """
    Minimal, safe normalization:
      - lowercase + trim
      - unify curly quotes
      - apply FreeTextMap replacements (longest-first)
      - a couple high-impact typo/alias fixes
    Returns a SINGLE normalized string you feed into your existing matcher.
    """
    if not raw:
        return ""
    text = raw.strip().lower()

    # normalize curly quotes to ascii to avoid miss matches
    text = (text
            .replace("’", "'")
            .replace("‘", "'")
            .replace("“", '"')
            .replace("”", '"'))

    # tiny typo fix that bites often
    text = text.replace("heatbeat", "heartbeat")

    # Apply Excel-driven phrase replacements, longest keys first to avoid partial shadowing
    if FT_MAP:
        for k in sorted(FT_MAP.keys(), key=len, reverse=True):
            pat = r'(?<!\w)' + re.escape(k) + r'(?!\w)'
            text = re.sub(pat, FT_MAP[k], text)
    
    text = apply_stop_phrases(text)
    return text

# Misleading phrases that shouldn't trigger body-part detection
STOP_PHRASES = {
    "side effects": "side_effects",  # neutralize "side" so it won't map to flank
}

def apply_stop_phrases(text: str) -> str:
    """Replace misleading phrases with inert tokens AFTER normalization."""
    t = text or ""
    for bad, safe in STOP_PHRASES.items():
        t = t.replace(bad, safe)
    return t


def load_logo():
    return Image.open("logo.png")

db = load_data()
logo = load_logo()

# ===== Body-part synonyms → category hints (resolved to DB labels) =====

def _cat_norm(s: str) -> str:
    """Canonicalize for matching category names (lowercase, strip, normalize quotes)."""
    return str(s).strip().lower().replace("’", "'").replace("‘", "'")

# Build map of canonical→exact label from the DB (so hints always resolve to real labels)
CAT_CANON = {}
for c in db["Primary Category"].dropna().astype(str).unique():
    key = _cat_norm(c)
    # First one wins; we want the exact label as it appears in the DB
    CAT_CANON.setdefault(key, c)

# Tight, human-curated body-part aliases with intended category hints.
# ⚠️ Hints are written using the **exact** strings from your DB above.
BODY_PART_SYNONYMS = {
    # Head & neck
    "head":         {"aliases": {"head", "skull"}, "category_hints": ["Bones, Joints & Muscles", "Trauma, Burns & Bites"]},
    "face":         {"aliases": {"face","facial","cheek","cheeks","jaw","jawbone","chin"}, "category_hints": ["ENT (Ear/Nose/Throat)","Dentistry (Teeth/Gums)","Dermatology (Skin/Scalp)","Ophthalmology (Eye Related)"]},
    "scalp":        {"aliases": {"scalp"}, "category_hints": ["Dermatology (Skin/Scalp)"]},
    "eye":          {"aliases": {"eye","eyes","eyelid","eyelids"}, "category_hints": ["Ophthalmology (Eye Related)"]},
    "ear":          {"aliases": {"ear","ears"}, "category_hints": ["ENT (Ear/Nose/Throat)"]},
    "nose":         {"aliases": {"nose","nostril","nostrils"}, "category_hints": ["ENT (Ear/Nose/Throat)","Respiratory (Cough/Breathing)"]},
    "throat":       {"aliases": {"throat","tonsil","tonsils"}, "category_hints": ["ENT (Ear/Nose/Throat)","Respiratory (Cough/Breathing)"]},
    "mouth_teeth":  {"aliases": {"mouth","gum","gums","tooth","teeth","tongue","lip","lips"}, "category_hints": ["Dentistry (Teeth/Gums)","ENT (Ear/Nose/Throat)"]},
    "neck":         {"aliases": {"neck","nape"}, "category_hints": ["Bones, Joints & Muscles","Endocrine (Lump/Swelling)"]},

    # Chest, back, abdomen
    "chest":        {"aliases": {"chest","rib","ribs"}, "category_hints": ["Respiratory (Cough/Breathing)","Bones, Joints & Muscles","Emergency (Time-critical)"]},
    "breast":       {"aliases": {"breast","breasts","nipple","nipples","areola"}, "category_hints": ["Women’s Health","Endocrine (Lump/Swelling)"]},
    "back":         {"aliases": {"back","upper back","lower back","waist"}, "category_hints": ["Bones, Joints & Muscles","Trauma, Burns & Bites"]},
    "abdomen":      {"aliases": {"abdomen","abdominal","belly","tummy","stomach","tommy"}, "category_hints": ["Gastrointestinal (Abdominal)"]},
    "flank_side":   {"aliases": {"flank","side"}, "category_hints": ["Increased thirst/urination","Gastrointestinal (Abdominal)"]},
    "hip":          {"aliases": {"hip","hips"}, "category_hints": ["Bones, Joints & Muscles","Trauma, Burns & Bites"]},
    "groin":        {"aliases": {"groin","crotch"}, "category_hints": ["Urinary & Sexual Health (UTI/STIs)","Men’s Health","Women’s Health"]},

    # Buttocks & anorectal
    "buttocks":     {"aliases": {"buttocks","butt","bum","backside","behind","ass"}, "category_hints": ["Bowel Complications (Stool Related)","Dermatology (Skin/Scalp)"]},
    "anus_rectum":  {"aliases": {"anus","anal","rectum","rectal"}, "category_hints": ["Bowel Complications (Stool Related)"]},

    # Upper limbs
    "shoulder":     {"aliases": {"shoulder","shoulders","collarbone","clavicle"}, "category_hints": ["Bones, Joints & Muscles","Trauma, Burns & Bites"]},
    "arm":          {"aliases": {"arm","arms"}, "category_hints": ["Bones, Joints & Muscles","Trauma, Burns & Bites","Endocrine (Lump/Swelling)"]},
    "elbow":        {"aliases": {"elbow","elbows"}, "category_hints": ["Bones, Joints & Muscles","Trauma, Burns & Bites"]},
    "forearm":      {"aliases": {"forearm","forearms"}, "category_hints": ["Bones, Joints & Muscles","Trauma, Burns & Bites"]},
    "wrist":        {"aliases": {"wrist","wrists"}, "category_hints": ["Bones, Joints & Muscles","Trauma, Burns & Bites"]},
    "hand":         {"aliases": {"hand","hands","palm","finger","fingers","thumb","thumbs"}, "category_hints": ["Bones, Joints & Muscles","Dermatology (Skin/Scalp)","Trauma, Burns & Bites"]},

    # Lower limbs
    "leg":          {"aliases": {"leg","legs"}, "category_hints": ["Bones, Joints & Muscles","Trauma, Burns & Bites","Endocrine (Lump/Swelling)"]},
    "thigh":        {"aliases": {"thigh","thighs","lap"}, "category_hints": ["Bones, Joints & Muscles","Trauma, Burns & Bites"]},
    "knee":         {"aliases": {"knee","knees"}, "category_hints": ["Bones, Joints & Muscles","Trauma, Burns & Bites","Endocrine (Lump/Swelling)"]},
    "calf":         {"aliases": {"calf","calves"}, "category_hints": ["Bones, Joints & Muscles","Endocrine (Lump/Swelling)"]},
    "shin":         {"aliases": {"shin","shins"}, "category_hints": ["Bones, Joints & Muscles","Trauma, Burns & Bites"]},
    "ankle":        {"aliases": {"ankle","ankles"}, "category_hints": ["Bones, Joints & Muscles","Trauma, Burns & Bites","Endocrine (Lump/Swelling)"]},
    "foot":         {"aliases": {"foot","feet","heel","heels","sole","toes","toe"}, "category_hints": ["Bones, Joints & Muscles","Dermatology (Skin/Scalp)","Trauma, Burns & Bites","Endocrine (Lump/Swelling)"]},

    # Genitals (gender gating happens later)
    "male_genitals":   {"aliases": {"penis","testicle","testicles","scrotum","balls","manhood","dick"}, "category_hints": ["Men’s Health","Urinary & Sexual Health (UTI/STIs)"]},
    "female_genitals": {"aliases": {"vagina","vaginal","vulva","labia","clitoris","womanhood","private part"}, "category_hints": ["Women’s Health","Urinary & Sexual Health (UTI/STIs)"]},

    # Skin (general)
    "skin":         {"aliases": {"skin"}, "category_hints": ["Dermatology (Skin/Scalp)"]},
}

# Resolve every hint to the exact DB label; drop/flag any that don’t resolve
BP_ALIAS_TO_HINTS = {}
_BAD_HINTS = []  # if any, fix the spelling/spacing in BODY_PART_SYNONYMS

for _canon, data in BODY_PART_SYNONYMS.items():
    for alias in data["aliases"]:
        resolved = set()
        for hint in data["category_hints"]:
            key = _cat_norm(hint)
            real = CAT_CANON.get(key)
            if real is None:
                _BAD_HINTS.append((alias, hint))
            else:
                resolved.add(real)
        if resolved:
            BP_ALIAS_TO_HINTS[alias.lower()] = resolved

# Optional: print unresolved hints to Streamlit sidebar (visible only to admins/devs)
if _BAD_HINTS:
    st.sidebar.warning("Unrecognized category_hints in BODY_PART_SYNONYMS (check spelling):")
    for alias, hint in _BAD_HINTS:
        st.sidebar.write(f"alias='{alias}'  hint='{hint}'  → NOT IN DB")
# ===== End body-part hints =====


# --- UTILITY FUNCTIONS ---


def is_gender_allowed(primary_category, gender, suppress_error=False):
    # Canonicalize: strip, lowercase, normalize quotes, collapse NBSP/whitespace
    s = str(primary_category or "")
    s = s.replace("’", "'").replace("‘", "'")
    s = re.sub(r"[\u00A0\s]+", " ", s).strip().lower()

    # Canonical labels to compare against
    womens = {"women's health"}     # categories, not conditions
    mens   = {"men's health"}       # categories, not conditions

    if gender == "Male" and s in womens:
        if not suppress_error:
            st.error("This category is not available for your selected gender")
        return False

    if gender == "Female" and s in mens:
        if not suppress_error:
            st.error("This category is not available for your selected gender")
        return False

    return True

def _row_allowed_for_gender(row, gender: str) -> bool:
    """Return True if this DB row is appropriate for the user's gender."""
    if not gender:
        return True
    # First, reuse your existing gate with no UI noise
    try:
        if not is_gender_allowed(str(row.get("Condition","")), gender, suppress_error=True):
            return False
    except Exception:
        pass
    # Then heuristic keywords across subcategory + condition + symptoms
    text = f"{row.get('SubCategory','')} {row.get('Condition','')} {row.get('Symptoms','')}".lower()
    male_terms   = ("male", "prostate", "penile", "testicular", "scrot", "ejacul", "erectile", "scrotum")
    female_terms = ("female", "vaginal", "vulva", "labia", "uterine", "cervic", "ovarian", "menstrual", "pregnan")
    if gender == "Female" and any(t in text for t in male_terms):
        return False
    if gender == "Male" and any(t in text for t in female_terms):
        return False
    return True

def display_grid(items, cols=3):
    rows = [items[i:i + cols] for i in range(0, len(items), cols)]
    for row in rows:
        columns = st.columns(len(row))
        for col, item in zip(columns, row):
            with col:
                if st.button(item, use_container_width=True):
                    return item
    return None

def generate_report():
    condition = st.session_state.current_condition
    user = st.session_state.user_data
    report = f"""
LEXAI SYMPTOM CHECKER REPORT
============================

Patient Details:
- Age: {user.get('age', 'N/A')}
- Gender: {user.get('gender', 'N/A')}

Assessment:
- Likely Condition: {condition['Condition'] if condition is not None else 'N/A'}
- Risk Factors: {', '.join(st.session_state.confirmed_risks) if st.session_state.confirmed_risks else 'None'}

Recommendation:
{condition['Escalated Recommendation' if st.session_state.get('is_high_risk') else 'Default Recommendation'] if condition is not None else ''}
"""
    return report

def similarity(a, b):
    return SequenceMatcher(None, a, b).ratio()

def match_conditions_by_symptoms(input_text, db):
    input_symptoms = [sym.strip().lower() for sym in input_text.split(",") if sym.strip()]
    matched_conditions = []
    for _, row in db.iterrows():
        db_symptoms = [sym.lower().strip() for sym in str(row["Symptoms"]).split(",") if sym.strip()]
        for user_sym in input_symptoms:
            for db_sym in db_symptoms:
                if user_sym in db_sym or db_sym in user_sym or similarity(user_sym, db_sym) >= 0.65:
                    matched_conditions.append(row)
                    break
            else:
                continue
            break
    return pd.DataFrame(matched_conditions).drop_duplicates()

def login_page():
    st.title("Lexy- Carekonnect Symptom Checker Login")

    # Create a form for login
    with st.form("login_form"):
        password = st.text_input("Enter Password", type="password")
        submit_button = st.form_submit_button("Login")

    # Check password
    if submit_button:
        if password == "lexmedical":
            st.session_state.logged_in = True
            st.session_state.page = "welcome"
            st.rerun()
        else:
            st.error("Incorrect password. Please try again.")




def welcome_page():
    # ─── 1) Inject custom CSS for styling ───
    st.markdown("""
    <style>
      /* Center and size the logo container */
      .logo-container {
        text-align: center;
        margin-bottom: 1.5rem;
      }
      /* Title styling */
      .welcome-title {
        text-align: center;
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 1rem;
      }
      /* Body text styling */
      .welcome-text {
        max-width: 600px;
        margin: 0 auto 2rem auto;
        font-size: 1.1rem;
        line-height: 1.6;
        color: #444;
      }
      /* Button sizing and coloring */
      .stButton > button {
        width: 220px;
        height: 50px;
        font-size: 1.1rem;
        border-radius: 8px;
        border: none;
        margin-top: 1rem;
      }
      .stButton > button[disabled] {
        background-color: #bbb !important;
        color: #fff !important;
        cursor: not-allowed;
      }
      .stButton > button:not([disabled]) {
        background-color: #e63946 !important;
        color: #fff !important;
      }
      /* Footer styling */
      .footer {
        text-align: center;
        font-size: 0.9rem;
        color: #666;
        margin-top: 3rem;
      }
    </style>
    """, unsafe_allow_html=True)

    # ─── 2) Logo ───
    st.markdown("<div class='logo-container'>", unsafe_allow_html=True)
    st.image(logo, width=120)
    st.markdown("</div>", unsafe_allow_html=True)

    # ─── 3) Welcome text ───
    st.markdown("<div class='welcome-title'>Lexy- AI Based Symptom Checker</div>", unsafe_allow_html=True)
    st.markdown("""
      <div class='welcome-text'>
         <strong>Hi 👋, I’m Lexy — here to help you make sense of your symptoms and feel more in control of your health.</strong><br><br>
        Lexy is an AI Triage tool that helps users better understand their symptoms and suggests next steps—whether that’s self-care, seeing a provider, or seeking urgent help.<br>
        It does not offer medical diagnoses and is not a substitute for care from a qualified health professional.<br><br>
        This tool is not recommended for children under 16, pregnant individuals, or those with multiple health conditions.<br><br>
        <strong>In case of emergency</strong>—such as chest pain, severe bleeding, or difficulty breathing—please call emergency services or go to the nearest hospital.
      </div>
    """, unsafe_allow_html=True)

    # ─── 4) Confirmation checkbox ───
    confirm = st.checkbox("I have read and understood the above")

    # ─── 5) Centered Start button, gated by checkbox ───
    _, center, _ = st.columns([1,2,1])
    with center:
        if st.button("Start Symptom Check", disabled=not confirm):
            st.session_state.page = "user_info"
            st.rerun()

    # ─── 6) Footer ───
    st.markdown("<div class='footer'>Powered by LexMedical Services LTD</div>", unsafe_allow_html=True)

    # ── Hidden Admin Access (testing only) ──
    pwd = st.sidebar.text_input("Dev code", type="password")
    if pwd == "Akinola":  # ← replace with your own secret
        st.sidebar.markdown("### Feature flags")
        st.sidebar.checkbox(
            "Enforce weak anchors",
            key="STRICT_WEAK_ANCHORS",
            value=st.session_state.get("STRICT_WEAK_ANCHORS", False),
            help="Generic tokens (pain/rash/fever) only count if overlapping a non-weak body part."
        )
        st.sidebar.checkbox(
            "Strict generic mode",
            key="STRICT_GENERIC_MODE",
            value=st.session_state.get("STRICT_GENERIC_MODE", False),
            help="For generic-only inputs, clamp primaries to hinted body parts or a generic→domain map."
        )

        if st.sidebar.button("View Analytics"):
            st.session_state.page = "analytics"
            st.rerun()

def user_info_page():
    st.image(logo, width=80)
    st.subheader("Before we begin, I’d like to know a little about you.")

    with st.form("user_info_form"):
        age = st.number_input("Age", min_value=0, max_value=120)
        # ←— THIS IS THE NEW “Pediatric Mode” NOTE
        if 0 <= age <= 14:
            st.info("👶 Ages 0 – 14 will activate Pediatric mode on the next screen.")

        gender = st.radio("Gender", ["Male", "Female"], horizontal=True)
        conditions = st.text_input(
            "Existing conditions",
            placeholder="Mention any long-term health issues you live with (like asthma or none)"
        )

        submit_col, _ = st.columns([1, 2])
        with submit_col:
            cont = st.form_submit_button("Continue →", type="primary")

    back_col, _ = st.columns([1, 2])
    with back_col:
        back = st.button("← Back")

    if back:
        st.session_state.page = "welcome"
        st.rerun()
    if cont:
        # ── Save demographics ──
        st.session_state.user_data['age']        = age
        st.session_state.user_data['gender']     = gender
        st.session_state.user_data['conditions'] = conditions

        # ── 1) Pediatrics shortcut for ages 0–14 ──
        if 0 <= age <= 14:
            # reset any free-text leftovers so source == db (has 'SubCategory')
            st.session_state.free_input_mode = False
            st.session_state.matched_conditions = pd.DataFrame()

            st.session_state.user_data['primary_category'] = "Pediatrics (Child Health)"
            st.session_state.page = "symptom_subcategory"
        else:
            # ── Adult/other flow unchanged ──
            st.session_state.page = "symptom_category"

        st.rerun()

def symptom_category_page():
    # ─── 0) Inject CSS for uniform, wrapped, full-width buttons ───
    st.markdown(
        """<style>
          .stButton > button {
            width: 100% !important;
            white-space: normal !important;
            word-wrap: break-word !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            min-height: 4rem !important;
            padding: 0.75rem 1rem !important;
          }
        </style>""",
        unsafe_allow_html=True
    )

    # ─── 1) Logo & heading ───
    st.image(logo, width=80)
    st.subheader("Let’s start with what’s bothering you today")

    # ─── 2) Gender guard ───
    current_gender = st.session_state.user_data.get('gender')
    if not current_gender:
        st.error("Gender not selected. Please go back.")
        return
    
    # ─── 2b) Age-aware category list (hide Pediatrics for 15+) ───
    current_age = st.session_state.user_data.get('age')

    valid_categories = []
    for cat in db["Primary Category"].unique():

        # Hide Pediatrics for ages 15+
        if (current_age is not None) and (current_age >= 15) and ("pediatrics" in _cat_norm(cat)):
            continue
        if is_gender_allowed(cat, current_gender, suppress_error=True):
            valid_categories.append(cat)

    def _row_allowed_for_gender(row, gender: str) -> bool:
        """Return True if this DB row is appropriate for the user's gender."""
        if not gender:
            return True
        # Reuse your gate without UI messages
        try:
            if not is_gender_allowed(str(row.get("Condition","")), gender, suppress_error=True):
                return False
        except Exception:
            pass
        # Heuristic keywords across subcategory + condition + symptoms
        text = f"{row.get('SubCategory','')} {row.get('Condition','')} {row.get('Symptoms','')}".lower()
        male_terms   = ("male", "prostate", "penile", "testicular", "scrot", "ejacul", "erectile", "scrotum")
        female_terms = ("female", "vaginal", "vulva", "labia", "uterine", "cervic", "ovarian", "menstrual", "pregnan")
        if gender == "Female" and any(t in text for t in male_terms):
            return False
        if gender == "Male"   and any(t in text for t in female_terms):
            return False
        return True
   
    # ─── 3) Render your 3-col grid via display_grid ───
    selected = display_grid(valid_categories, cols=3)

    # ─── 4) Handle a valid selection ───
    if selected and is_gender_allowed(selected, current_gender):
        st.session_state.free_input_mode = False
        st.session_state.matched_conditions = pd.DataFrame()
        st.session_state.user_data['primary_category'] = selected
        st.session_state.page = "symptom_subcategory"
        st.rerun()

    # ─── 5) Free-text fallback ───
    if st.button("Can’t find your symptoms? Enter them here"):
        st.session_state.page = "symptom_free_input"
        st.rerun()

    # ─── 6) Back button ───
    if st.button("← Back"):
        st.session_state.page = "user_info"
        st.rerun()

def symptom_free_input_page():
    import re
    from collections import defaultdict
    import pandas as pd
    from datetime import datetime

    st.image(logo, width=80)
    st.subheader("What are your symptoms?")
    st.markdown("Use 1–2 simple symptoms. Separate multiple with commas (e.g., headache, fever, dizziness, leg pain)")

    # ---------- Local helpers (scoped to this function; safe to remove/move later) ----------
    def _ck_normalize(s: str) -> str:
        # keep commas/semicolons for phrase splits; letters/digits/spaces only
        return re.sub(r'\s+', ' ', re.sub(r'[^A-Za-z0-9\s,;]', ' ', str(s).lower())).strip()

    def _ck_tokenize(s: str):
        # tokens are words >=3 letters
        return re.findall(r"[A-Za-z]{3,}", str(s).lower())

    def _ck_stem(token: str) -> str:
        t = token.lower()
        # conservative suffix strip (single pass)
        for suff in ("ness", "ions", "ion", "ing", "ed", "es", "s"):
            if len(t) > 4 and t.endswith(suff):
                t = t[:-len(suff)]
                break
        # y -> i normalization (dizzy -> dizzi)
        if t.endswith("y") and len(t) >= 4:
            t = t[:-1] + "i"
        return t
    
    def _ck_detect_body_part_hints(free_text_norm: str):
        """Return a set of category labels hinted by body-part aliases in the input."""
        hints = set()
        s = f" {free_text_norm} "

        def _is_weak(a): return a in WEAK_ANCHORS

        # phrase-level detection (e.g., 'lower back'); skip weak anchors if flag is on
        for alias, cats in BP_ALIAS_TO_HINTS.items():
            if f" {alias} " in s:
                if st.session_state.get("STRICT_WEAK_ANCHORS", False) and _is_weak(alias):
                    continue
                hints |= cats

        # token-level detection; same skip rule
        for tok in set(_ck_tokenize(free_text_norm)):
            if st.session_state.get("STRICT_WEAK_ANCHORS", False) and tok in WEAK_ANCHORS:
                continue
            cats = BP_ALIAS_TO_HINTS.get(tok, set())
            hints |= cats
        return hints



    # Minimal curated synonyms (can be expanded later; not exhaustive by design)
    _CK_SYNONYMS = {
    # Skin
    "rash": {"rashes", "hives", "urticaria", "dermatitis", "exanthem", "eruption"},
    "itch": {"itchy", "itching", "pruritus"},

    # Neuro
    "dizziness": {"dizzy", "lightheaded", "lightheadedness", "giddiness"},
    "headache": {"migraine", "head pain"},

    # GI
    "stomach": {"belly", "tummy", "abdomen", "abdominal"},
    "bloating": {"gas", "gassy", "bloated"},
    "constipation": {"constipated"},
    "diarrhea": {"diarrhoea", "runny stool", "loose stool", "watery stool"},
    "vomit": {"vomiting", "emesis", "throwing up"},

    # Resp
    "breathlessness": {"shortness of breath", "sob", "dyspnea", "dyspnoea"},
    "phlegm": {"mucus", "sputum", "catarrh"},

    # GU
    "urinate": {"urination", "urinating", "pee", "peeing", "passing urine"},
    "burning": {"burning urination", "dysuria"},

    # Women’s health
    "period": {"menstruation", "menses", "menstrual", "cramps", "dysmenorrhea", "period pains"},
    "vaginal_discharge": {"vaginal discharge", "vag discharge"},
    }
    

    def _ck_variants(token: str):
        t = token.lower().strip()
        base = {t, _ck_stem(t)}
        infl = set()

        # add/remove simple inflections
        for suff in ("s", "es", "ed", "ing", "ion", "ions", "ness"):
            if t.endswith(suff) and len(t) > len(suff) + 2:
                infl.add(t[:-len(suff)])
            infl.add(t + suff)

        # y <-> i (dizzy -> dizzi)
        if t.endswith("y") and len(t) >= 4:
            infl.add(t[:-1] + "i")

        syn = _CK_SYNONYMS.get(t, set())

        out = base | infl | syn | {_ck_stem(x) for x in (infl | syn)}
        return {x for x in out if len(x) >= 3}

    def _ck_build_row_index(df, pri_col="Primary Category", sym_col="Symptoms"):
        rows = []
        for i, r in df.iterrows():
            cat = _ck_normalize(r.get(pri_col, ""))
            sym = _ck_normalize(r.get(sym_col, ""))
            cat_toks = set(_ck_tokenize(cat))
            sym_toks = set(_ck_tokenize(sym))
            rows.append({
                "idx": i,
                "cat": r.get(pri_col, ""),
                "sym": r.get(sym_col, ""),
                # include both raw token and stem for fast exact/stem checks
                "cat_tokens": set.union(cat_toks, {_ck_stem(t) for t in cat_toks}),
                "sym_tokens": set.union(sym_toks, {_ck_stem(t) for t in sym_toks}),
            })
        return rows

    def _ck_score_categories_and_subset(free_text, df, pri_col="Primary Category", sym_col="Symptoms"):
        # B2 – part 1: split normalize & tokenize so we can reuse free_norm

        # Apply full phrase normalization (includes FreeTextMap + stop phrases)
        free_norm = normalize_free_text(free_text)

        tokens    = set(_ck_tokenize(free_norm))

        if not tokens:
            return [], df.iloc[0:0]

        # detect hinted categories from body-part aliases (needs _ck_detect_body_part_hints + BP_ALIAS_TO_HINTS)
        hint_boosts = _ck_detect_body_part_hints(free_norm)

        GENERIC_FLAT = set().union(*GENERIC_FAMILY.values())
        def _is_generic(tok: str) -> bool:
            return (tok in GENERIC_FLAT) or (_ck_stem(tok) in GENERIC_FLAT)
        non_generic = {t for t in tokens if not _is_generic(t)}
        generic_only = (len(non_generic) == 0)



        # Which generics are present in the input?
        present_generics = set()
        for g, fam in GENERIC_FAMILY.items():
            if any((t in fam) or (_ck_stem(t) in fam) for t in tokens):
                present_generics.add(g)

        # Union of allowed substrings for those generics (from GENERIC_TO_CATKEYS)
        dyn_allowed = set().union(*(GENERIC_TO_CATKEYS.get(g, set()) for g in present_generics))


        # Build body-part tokens from our alias map so plurals/phrases (e.g., "legs", "knees", "lower back")
        # are treated as first-class tokens. Keep simple side modifiers too.
        BODY_PART_TOKENS = set(BP_ALIAS_TO_HINTS.keys()) | {
            # explicit fallbacks (in case a term is missing from aliases)
            "head","scalp","face","eye","ear","nose","throat","neck","chest","breast","back",
            "shoulder","arm","elbow","forearm","wrist","hand","finger","hip","groin","abdomen","stomach",
            "belly","flank","waist","buttock","leg","thigh","knee","calf","shin","ankle","foot","toe",
            # weak/broad anchors (filtered when STRICT_WEAK_ANCHORS is True)
            "skin","body","area","surface","left","right","upper","lower","middle","central","lateral",
            "inner","outer"
        }

        # Include stems so "legs" matches "leg", "knees" → "knee", etc.
        input_parts = {
            (_ck_stem(t) if _ck_stem(t) in BODY_PART_TOKENS else t)
            for t in tokens
            if (t in BODY_PART_TOKENS) or (_ck_stem(t) in BODY_PART_TOKENS)
        }

        token_variants = {t: (_ck_variants(t) | {t, _ck_stem(t)}) for t in tokens}
        rows = _ck_build_row_index(df, pri_col=pri_col, sym_col=sym_col)

        from collections import defaultdict
        rows_by_cat = defaultdict(list)
        for r in rows:
            rows_by_cat[r["cat"]].append(r)

        cat_stats = {}
        cat_rows_hit = defaultdict(set)

        # ---- Stage 1: category-name hits (plus body-part boost)
        for cat, rlist in rows_by_cat.items():
            cat_tokens_union = set()
            for r in rlist:
                cat_tokens_union |= r["cat_tokens"]

            cat_hits = 0
            for t in tokens:
                vset = token_variants[t]
                if any((v in cat_tokens_union) for v in vset):
                    cat_hits += 1

            # B2 – part 2: apply hint boost
            if cat in hint_boosts:
                cat_hits += 1

            cat_stats[cat] = {"cat_hits": cat_hits, "sym_hits": 0}

        # ---- Stage 2: symptoms hits (unchanged)
        for cat, rlist in rows_by_cat.items():
            sym_hits = 0
            for r in rlist:
                sym_tokens = r["sym_tokens"]
                row_hit = False
                

                cat_tokens = r["cat_tokens"]
                # Consider stems from row text to catch forms like "knees", "hands", etc.
                row_terms  = (sym_tokens | cat_tokens) | {_ck_stem(x) for x in (sym_tokens | cat_tokens)}
                row_parts  = BODY_PART_TOKENS.intersection(row_terms)

                for t in tokens:
                    vset = token_variants[t]

                    if t in non_generic:
                        # Non-generic tokens may match exactly or with tight fuzzy
                        if any((v in sym_tokens) for v in vset):
                            row_hit = True
                            break
                        if any(ok_pair(t, s) for s in sym_tokens):
                            row_hit = True
                            break
                    else:
                        # Generic token (e.g., pain, rash, fever)
                        if any((v in sym_tokens) for v in vset):
                            row_ok = False

                            # If a body part was provided, require overlap (respect weak-anchor flag if ON)
                            if input_parts:
                                overlap = (row_parts & input_parts)
                                if st.session_state.get("STRICT_WEAK_ANCHORS", False):
                                    overlap = {p for p in overlap if p not in WEAK_ANCHORS}
                                if overlap:
                                    row_ok = True

                            # B - generic+hint fallback:
                            # If the user hinted this category via a body-part alias (e.g., "leg"),
                            # allow the generic hit (e.g., "pain") to count even if the row itself
                            # doesn't mention that body part explicitly.
                            if (not row_ok) and (cat in hint_boosts):
                                row_ok = True

                            # If NO body part (e.g., input normalized to "rash"),
                            # allow only when the category name is in the generic's domain
                            if not input_parts and dyn_allowed:
                                if any(k in _cat_norm(cat) for k in dyn_allowed):
                                    row_ok = True

                            if row_ok:
                                row_hit = True
                                break



                if row_hit:
                    sym_hits += 1
                    cat_rows_hit[cat].add(r["idx"])
            # Pairwise boost: reward rows that hit ≥2 user tokens
            pair_boost = 0
            if len(tokens) >= 2:
                for r in rlist:
                    sym_tokens = r["sym_tokens"]
                    hit_count = 0
                    for t in tokens:
                        vset = token_variants[t]
                        if any((v in sym_tokens) for v in vset):
                            hit_count += 1
                        if hit_count >= 2:
                            pair_boost += 1
                            break

            cat_stats[cat]["sym_hits"] = sym_hits + 0.5 * pair_boost

        # ---- scoring & selection (unchanged)
        ranking = []
        for cat, stv in cat_stats.items():
            score = 1.0 * stv["cat_hits"] + 2.0 * stv["sym_hits"]
            ranking.append((cat, score, stv["sym_hits"], len(cat_rows_hit[cat])))
        ranking.sort(key=lambda x: (x[1], x[2], x[3]), reverse=True)

        # Admit categories:
        # - normal: need ≥1 symptom-level hit
        # - generic-only with no body-part hints: also allow by generic→domain map
        current_gender = st.session_state.user_data.get('gender')
        current_age    = st.session_state.user_data.get('age')

        # Build broad allow-list keys only for generic-only/no-hints
        allow_keys = set()
        if generic_only and not input_parts:
            present_generics = set()
            for g, fam in GENERIC_FAMILY.items():
                if any((t in fam) or (_ck_stem(t) in fam) for t in tokens):
                    present_generics.add(g)
            # Wide domains from your curated map (fatigue → resp/sleep/mental/infect/neuro/…)
            allow_keys = set().union(*(GENERIC_TO_CATKEYS.get(g, set()) for g in present_generics))

        def _allowed_by_generic_domain(cat_name: str) -> bool:
            return bool(allow_keys and (_cat_to_key(cat_name) & allow_keys))

        valid_cats = {
            cat for (cat, score, sym_hits, _n) in ranking
            if (
                (sym_hits >= 1) or _allowed_by_generic_domain(cat)   # ← key change
            )
            and (score >= 1.0)  # slightly looser when allowing by domain
            and not (
                (current_age is not None)
                and (current_age >= 15)
                and ("pediatrics" in _cat_norm(cat))
            )
            and is_gender_allowed(cat, current_gender, suppress_error=True)
        }

        # For generic-only inputs, tighten sensibly when the feature flag is ON
        if _flag("STRICT_GENERIC_MODE") and generic_only:
            # If the user gave a strong body part, clamp to hinted categories
            strong_parts = input_parts - WEAK_ANCHORS
            if strong_parts and hint_boosts:
                hinted = {cat for cat in valid_cats if cat in hint_boosts}
                if hinted:
                    valid_cats = hinted

            # If no strong body part, use a generic→domain whitelist
            if not strong_parts:
                present_generics = set()
                for g, fam in GENERIC_FAMILY.items():
                    if any((t in fam) or (_ck_stem(t) in fam) for t in tokens):
                        present_generics.add(g)

                dyn_allowed = set().union(*(GENERIC_TO_CATKEYS.get(g, set()) for g in present_generics)) or set()

                if dyn_allowed:
                    def _ok_cat(name: str) -> bool:
                        keys = _cat_to_key(name)   # extract tokens like {'toxic','poison','exposure'}
                        return bool(keys & dyn_allowed)  # intersection test
                    filtered = {cat for cat in valid_cats if _ok_cat(cat)}
                    if filtered:
                        valid_cats = filtered
        else:
            # Generic-only (no strong body-part hints): use the broad curated map
            if generic_only and not hint_boosts:
                # Which generics are present in the input?
                present_generics = {
                    g for g, fam in GENERIC_FAMILY.items()
                    if any((t in fam) or (_ck_stem(t) in fam) for t in tokens)
                }

                # Wide allow-list from GENERIC_TO_CATKEYS (e.g., fatigue → resp/sleep/mental/infect/neuro/…)
                dyn_allowed = set().union(*(GENERIC_TO_CATKEYS.get(g, set()) for g in present_generics))

                if dyn_allowed:
                    def _ok_cat(name: str) -> bool:
                        # tokenize title: "Sleep & Mental Health" → {"sleep","mental","health",...}
                        keys = _cat_to_key(name)
                        return bool(keys & dyn_allowed)

                    filtered = {cat for cat in valid_cats if _ok_cat(cat)}
                    if filtered:
                        valid_cats = filtered

        # persist flag so next screen can clamp to Top-3 (you already read this later)
        st.session_state.user_data["generic_only"] = bool(generic_only)

        # Keep only rows that actually matched the user’s tokens, not every row in the category
        match_ids = set()
        for cat in valid_cats:
            match_ids |= cat_rows_hit[cat]   # these are the row indices that got a symptom hit

        subset = df.loc[sorted(match_ids)] if match_ids else df.iloc[0:0]

        ordered_cats = [cat for (cat, score, sym_hits, _n) in ranking if cat in valid_cats]
        return ordered_cats, subset
    
        # ---------- End local helpers ----------

    # — Wrap input & submit in a form so Enter works —
    with st.form("free_input_form"):
        symptom_input = st.text_input("Your symptoms:")
        search = st.form_submit_button("Search Symptoms")

    if search:
        # ===== CK: Category-first free-text matching =====
        if not symptom_input.strip():
            st.warning("Please enter at least one symptom to search.")
            return

        # Use your DataFrame 'db' and expected columns
        ordered_cats, subset = _ck_score_categories_and_subset(symptom_input, db,
                                                               pri_col="Primary Category",
                                                               sym_col="Symptoms")

        if subset.empty or not ordered_cats:
            # Log and show the same UX actions as before
            try:
                log_failure({
                    "timestamp": datetime.utcnow().isoformat(),
                    "step":      "free_text_match_ck",
                    "input":     symptom_input,
                    "reason":    "no_symptom_match"
                })
            except Exception:
                pass

            st.warning("❗️ “Let’s try that again. We couldn’t find a close match yet. Try one or two simple symptoms (e.g., rash, fever, cough) or pick a body area. You can also speak with a doctor.")
            if st.button("Try Again"):
                st.rerun()
            if st.button("Speak to a Doctor"):
                st.session_state.page = "fallback_page"
                st.rerun()
            if st.button("Start Over"):
                st.session_state.clear()
                st.session_state.page = "welcome"
                st.rerun()
            return

        # Success: save results & advance (retain UI/UX flow)
        st.session_state.free_input_mode            = True
        st.session_state.matched_conditions         = subset
        st.session_state.user_data['free_symptoms'] = symptom_input
        st.session_state.free_primary_ranking       = ordered_cats  # ordered by relevance score
        st.session_state.page                       = "symptom_primary_category_freeinput"
        st.rerun()
        # ===== End CK block =====

    # — Back button outside the form —
    if st.button("← Back"):
        st.session_state.page = "symptom_category"
        st.rerun()



def symptom_primary_category_freeinput_page():
    # ── Guard: only allow free-text category pick when we actually have matches ──
    if not st.session_state.get("free_input_mode") or st.session_state.matched_conditions.empty:
        st.session_state.page = "symptom_category"
        st.rerun()

    st.image(logo, width=80)
    st.subheader("Review these categories to see what feels closest to how you’re feeling")
    st.markdown(
        "<div style='font-size:0.95rem; font-weight:700; margin-top:-0.35rem;'>"
        "Some symptoms are time-critical and may have been classified as "
        "<span style='color:#b91c1c;'>Emergency</span>."
        "</div>",
        unsafe_allow_html=True,
    )
    
    # now safe: we know matched_conditions exists and has columns
    subset = st.session_state.matched_conditions
    current_gender = st.session_state.user_data.get('gender')
    current_age    = st.session_state.user_data.get('age')

    # =========================
    # Clinical-aware ranking
    # =========================
    import re
    norm = lambda s: (s / s.max()) if len(s) and s.max() > 0 else s*0

    # Use the user’s free text for keyword signal
    q = (st.session_state.user_data.get("free_symptoms", "") or "").lower()
    tokens = [t for t in re.findall(r"[a-z]{3,}", q)
              if t not in {"the","and","for","with","from","that","this","these","those",
                           "your","have","has","are","was","were"}]
    # If no tokens, make a pattern that matches nothing
    pat = r"\b(" + "|".join(map(re.escape, tokens)) + r")\b" if tokens else r"$^"

    # Detect the special case ONCE (based on your DB reality)
    gender_norm = str(current_gender or "").strip().lower()
    male_breast_query = (
        gender_norm.startswith("male")
        and re.search(r"\b(breast|breasts|nipple|nipples|areola|pecs?)\b", q, flags=re.I)
    )

    tmp = subset.copy()
    hay = tmp[["Symptoms","Clarifying Questions 1","Clarifying Questions2","RiskFlags","Labeling Rule"]] \
            .astype(str).agg(" ".join, axis=1).str.lower()
    tmp["kw_hits"] = hay.str.count(pat)
    # Enforce row-level gender gating here (so off-target categories can't bubble up)
    if current_gender:
        tmp = tmp[tmp.apply(lambda r: _row_allowed_for_gender(r, current_gender), axis=1)]
        grp = tmp.groupby("Primary Category").agg(
        kw=("kw_hits", "mean"),
        freq=("Primary Category", "size"),
    )

    # Small priors only for fatigue/tired/weakness-like queries
    priors = {}
    if re.search(r"\b(fatigue|tired|weakness|malaise|exhausted)\b", q):
        priors = {
            "Headache, Dizziness & Fatigue": 1.00,
            "Infectious Diseases (Fever/Pain)": 0.85,
            "Sleep & Mental Health (Insomnia/Anxiety)": 0.80,
            "Respiratory (Cough/Breathing)": 0.70,
            "Increased Thirst/Urination": 0.65,
            "Bones, Joints & Muscles": 0.55,
            "Gastrointestinal (Abdominal)": 0.50,
            "Emergency (Time-critical)": 0.45,
            "Toxicology (Poison/Exposure)": 0.40,
        }

    grp["kw_n"]   = norm(grp["kw"])
    grp["freq_n"] = norm(grp["freq"].astype(float))
    grp["prior"]  = grp.index.to_series().map(lambda c: priors.get(c, 0.0))
    grp["score"]  = 0.50*grp["kw_n"] + 0.30*grp["prior"] + 0.20*grp["freq_n"]

    # Ordered list we will render
    ordered = grp["score"].sort_values(ascending=False).index.tolist()

    # --- Soft notice if categories were hidden by gender (no logic change) ---
    hidden_by_gender = [c for c in ordered if not is_gender_allowed(c, current_gender, suppress_error=True)]

    def _looks_womens(c: str) -> bool:
        s = _cat_norm(c)
        return ("women" in s) or ("breast" in s) or ("gyne" in s) or ("obstet" in s)

    def _looks_mens(c: str) -> bool:
        s = _cat_norm(c)
        return ("men's health" in s) or ("prostate" in s) or ("testicular" in s) or ("scrotum" in s)

    if hidden_by_gender:
        if gender_norm.startswith("male") and any(_looks_womens(c) for c in hidden_by_gender):
            st.info(
                "Your input includes terms often evaluated under **Women’s Health** "
                "(e.g., breast). Because your profile is set to **Male**, those options "
                "are hidden. If that’s not correct, go back and change gender."
            )
        elif gender_norm.startswith("female") and any(_looks_mens(c) for c in hidden_by_gender):
            st.info(
                "Your input includes terms often evaluated under **Men’s Health** "
                "(e.g., prostate/testicular). Because your profile is set to **Female**, "
                "those options are hidden. If that’s not correct, go back and change gender."
            )

    # ============== age & gender gating + clean list ==============
    primaries = []
    for cat in ordered:
        # Age gate: hide Pediatrics for adults (15+)
        if (current_age is not None) and (current_age >= 15) and ("pediatrics" in str(cat).strip().lower()):
            continue
        if not is_gender_allowed(cat, current_gender, suppress_error=True):
            continue
        primaries.append(cat)

    # ============== FINAL HARD CLAMP for Male + "breast" =================
    # This is DB-aware and guarantees ENT/Resp/Dent/Neuro won't show here.
    if male_breast_query:
        allowed = ["Endocrine (Lump/Swelling)", "Dermatology (Skin/Scalp)"]
        try:
            db_cats = set(map(str, db["Primary Category"].dropna().unique().tolist()))
        except Exception:
            db_cats = set()

        allowed_present = [c for c in allowed if c in db_cats]
        primaries_forced = [c for c in primaries if c in allowed_present]

        if primaries_forced:
            primaries = primaries_forced
        else:
            # inject allowed categories at top if none survived the earlier passes
            primaries = allowed_present if allowed_present else primaries

        # only show note once
        if allowed_present:
            st.info("Because you selected **Breast** in Male Gender Mode- these are only **male breast** concerns")
    # =====================================================================

    if not primaries:
        st.warning("We found matches, but none are available for your selected gender/age.")
        if st.button("← Back"):
            st.session_state.page = "symptom_free_input"
            st.rerun()
        return

    # =============================
    # Top-8 + “Show all (N)” UI
    # =============================
    INITIAL_LIMIT = 8
    _toggle_key = "freeinput_show_all_categories"

    # Reset the toggle if we're not in free-input mode anymore (safety)
    if not st.session_state.get("free_input_mode"):
        st.session_state.pop(_toggle_key, None)

    show_all = bool(st.session_state.get(_toggle_key, False))

    visible_primaries = (
        primaries if (show_all or len(primaries) <= INITIAL_LIMIT)
        else primaries[:INITIAL_LIMIT]
    )

    # Render the visible grid
    choice = display_grid(visible_primaries, cols=2)
    if choice:
        st.session_state.user_data['primary_category'] = choice
        st.session_state.page = "symptom_subcategory"
        st.rerun()

    # Toggle control (only if more than INITIAL_LIMIT)
    if len(primaries) > INITIAL_LIMIT:
        cols = st.columns(2)
        with cols[0]:
            if not show_all:
                if st.button(f"Show all ({len(primaries)})"):
                    st.session_state[_toggle_key] = True
                    st.rerun()
            else:
                if st.button("Show less"):
                    st.session_state[_toggle_key] = False
                    st.rerun()

    # Back button
    if st.button("← Back"):
        st.session_state.page = "symptom_free_input"
        st.rerun()




def symptom_subcategory_page():
    st.image(logo, width=80)
    st.subheader("I’ll guide you — select the category that best fits")

    # ── Ensure we have a primary category ──
    primary = st.session_state.user_data.get("primary_category")
    current_age = st.session_state.user_data.get("age")

    # 🚫 Hard gate: no Pediatrics for adults even if carried over via free-text
    if (current_age is not None) and (current_age >= 15) and ("pediatrics" in str(primary).strip().lower()):
        st.warning("This path is for children under 15. Please choose another category.")
        if st.button("← Back"):
            st.session_state.page = (
                "symptom_primary_category_freeinput"
                if st.session_state.get("free_input_mode", False)
                else "symptom_category"
            )
            st.rerun()
        return


    # ── 3) Pediatric‐mode banner ──
    if primary == "Pediatrics (Child Health)":
        st.info("🧸 Pediatric mode activated—these subcategories are age-appropriate for 0–14 years.")

    # ── Rest of your existing flow ──
    source = (
        st.session_state.matched_conditions
        if st.session_state.get("free_input_mode", False)
        else db
    )
    filtered = source[source["Primary Category"] == primary]

    # Gender-aware row filtering before we build the subcategory list
    current_gender = st.session_state.user_data.get("gender")
    if current_gender:
        filtered = filtered[filtered.apply(lambda r: _row_allowed_for_gender(r, current_gender), axis=1)]

    # pick the data source for this page
    source = st.session_state.matched_conditions if st.session_state.get("free_input_mode", False) else db

    # --- tiny guard to avoid KeyError: fall back if the current source lacks SubCategory
    if source.empty or ("SubCategory" not in source.columns):
        source = db

    filtered = source[source["Primary Category"] == st.session_state.user_data['primary_category']]
    raw_subcats = sorted(filtered["SubCategory"].dropna().unique())


    # Build subcategories from remaining rows
    raw_subcats = sorted(filtered["SubCategory"].dropna().unique())

    # Belt-and-suspenders: hide explicitly gendered titles that don't match
    def _subcat_allowed(sc: str, gender: str) -> bool:
        if not gender:
            return True
        s = str(sc).lower()
        male_terms   = ("male", "prostate", "penile", "testicular", "scrot", "ejacul", "erectile", "scrotum")
        female_terms = ("female", "vaginal", "vulva", "labia", "uterine", "cervic", "ovarian", "menstrual", "pregnan")
        if gender == "Female" and any(t in s for t in male_terms):   return False
        if gender == "Male"   and any(t in s for t in female_terms): return False
        return True

    subcats = [sc for sc in raw_subcats if _subcat_allowed(sc, current_gender)]

    choice = display_grid(subcats, cols=2)

    if choice:
        st.session_state.user_data["subcategory"] = choice
        st.session_state.current_condition = filtered[filtered["SubCategory"] == choice].iloc[0]
        st.session_state.page = "symptom_selection"
        st.rerun()

    if st.button("← Back"):
        st.session_state.page = (
            "symptom_primary_category_freeinput"
            if st.session_state.get("free_input_mode", False)
            else "symptom_category"
        )
        st.rerun()

def symptom_selection_page():
    st.image(logo, width=80)
    st.subheader("Tell me about your symptoms")

    primary = st.session_state.user_data.get("primary_category")
    subcat  = st.session_state.user_data.get("subcategory")
    if not primary or not subcat:
        st.error("Category or subcategory missing. Please start over.")
        if st.button("Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # 1) Decide source: full DB for normal, matched_conditions for free-text
    source = st.session_state.matched_conditions if st.session_state.get("free_input_mode") else db

    # 2) Filter to your chosen subcategory
    subset = source[
        (source["Primary Category"] == primary) &
        (source["SubCategory"]      == subcat)
    ]

    # Gender-aware row filtering (row-level, not just titles)
    gender = st.session_state.user_data.get("gender")
    if gender:
        subset = subset[subset.apply(lambda r: _row_allowed_for_gender(r, gender), axis=1)]
    if subset.empty:
        st.error("No conditions found here—please go back and choose another subcategory.")
        if st.button("← Back"):
            st.session_state.page = "symptom_subcategory"
            st.rerun()
        return

    # --- Helper for robust deduplication ---
    import re  # keep at top of file if not already imported

    def _norm_sym_label(s: str) -> str:
        """
        Normalize a symptom label for deduping:
        - lowercase + trim
        - collapse spaces (incl. NBSP) to single spaces
        - unify quotes/dashes
        - strip trailing punctuation
        """
        t = str(s or "").strip().lower()
        t = t.replace("’", "'").replace("‘", "'").replace("“", '"').replace("”", '"')
        t = t.replace("–", "-").replace("—", "-")
        t = re.sub(r"[\s\u00A0]+", " ", t)
        t = re.sub(r"[.,;:()\[\]\-]+$", "", t).strip()
        return t

    # 3) Aggregate symptoms with robust de-duplication
    seen = {}  # norm_key -> first clean display
    for row in subset["Symptoms"].dropna():
        for s in str(row).split(","):
            raw = s.strip()
            if not raw:
                continue
            key = _norm_sym_label(raw)
            seen.setdefault(key, raw)  # keep the first clean version

    # 4) Render deduped, sorted list
    options = sorted(seen.values(), key=lambda x: x.lower())
    selected = st.multiselect("Review Carefully and Select all that apply:", options)

    # 5) Navigation
    col1, col2 = st.columns([1,3])
    with col1:
        if st.button("← Back"):
            st.session_state.page = "symptom_subcategory"
            st.rerun()
    with col2:
        if st.button("Continue →"):
            st.session_state.user_data['selected_symptoms'] = selected
            st.session_state.page = "clarifying_questions"
            st.rerun()

def clarifying_questions_page():
    st.image(logo, width=80)
    st.subheader("To guide me better, Pick the option that most closely matches your symptoms.")

    # --- helpers (local, minimal) ---
    import re
    _requires_cq2_re = re.compile(r"\bcq2\b", flags=re.IGNORECASE)

    def _norm(s):
        return str(s).strip()

    def _row_requires_cq2(row) -> bool:
        """Return True if this row's Labeling Rule explicitly mentions 'cq2'."""
        return bool(_requires_cq2_re.search(str(row.get("Labeling Rule", ""))))

    def _row_cq2_eligible(row, answers: dict) -> bool:
        """
        Row is CQ2-eligible iff:
          • its rule does NOT mention cq2, OR
          • its own CQ2 was answered Yes.
        """
        if not _row_requires_cq2(row):
            return True
        q2 = _norm(row.get("Clarifying Questions2", ""))
        return bool(q2) and answers.get(q2) == "Yes"
    # --- end helpers ---

    # 1️⃣ Build the subset of rows for this pathway
    primary = st.session_state.user_data.get("primary_category")
    subcat  = st.session_state.user_data.get("subcategory")

    # pick source: full DB if normal, else your matched free-text subset
    source = db if not st.session_state.get("free_input_mode", False) else st.session_state.matched_conditions

    # filter to the chosen primary/subcategory
    subset = source[
        (source["Primary Category"] == primary) &
        (source["SubCategory"]      == subcat)
    ]

    # PRECOMPUTE the original best condition for "closest condition" fallback
    # Recompute whenever the explored key changes, and never pick the explored condition itself.
    _peer_key_norm = str(st.session_state.get("peer_explore_key", "")).strip().lower()
    if st.session_state.get("peer_explore_mode") and _peer_key_norm:
        if st.session_state.get("_explore_prev_key") != _peer_key_norm:
            def _rank_key_local(r):
                conf = str(r.get("Labeling Confidence", "Low")).lower()
                conf_rank = {"high": 2, "medium": 1, "low": 0}.get(conf, 0)
                acu = int(r.get("Acuity Level", 1) or 1)
                rule_len = len(str(r.get("Labeling Rule", "")))
                name = str(r.get("Condition", ""))
                return (-conf_rank, -acu, rule_len, name)

            base_ranked = (
                subset.assign(__rk=subset.apply(_rank_key_local, axis=1))
                      .sort_values("__rk", ascending=True)
            )

            closest = None
            if not base_ranked.empty:
                for c in base_ranked["Condition"].astype(str):
                    c_norm = c.strip().lower()
                    if c_norm != _peer_key_norm:
                        closest = c.strip()
                        break

            st.session_state["_explore_prev_best_condition"] = closest  # may be None
            st.session_state["_explore_prev_key"] = _peer_key_norm

    # --- PEER EXPLORE GUARD: if we arrived via "Explore", lock to that single condition ---
    if st.session_state.get("peer_explore_mode") and st.session_state.get("peer_explore_key"):
        _peer_key = st.session_state["peer_explore_key"].strip().lower()
        subset = subset[subset["Condition"].astype(str).str.strip().str.lower() == _peer_key]
        # If nothing matches (defensive), drop the flag so normal flow continues
        if subset.empty:
            # st.session_state["peer_explore_mode"] = False
            # st.session_state["peer_explore_key"]  = ""
            pass  # keep block non-empty to avoid IndentationError

    # NEW: restrict to rows that overlap with user-selected symptoms
    selected_syms = set(st.session_state.user_data.get("selected_symptoms", []))
    if selected_syms:
        def _row_matches(row):
            row_syms = {s.strip() for s in str(row.get("Symptoms", "")).split(",") if s.strip()}
            return bool(selected_syms & row_syms)
        subset = subset[subset.apply(_row_matches, axis=1)]

    if subset.empty:
        st.error("Despite Similar Features, the initial Symptoms selected is not enough to explore this condition; Please start over.")
        if st.button("Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # 2️⃣ Stage 1: ask every unique CQ1 in this subset
    if not st.session_state.get("cq1_done"):
        cq1s     = list(subset["Clarifying Questions 1"].dropna().unique())
        answers1 = {}
        with st.form("cq1_form"):
            for i, q in enumerate(cq1s, 1):
                ans = st.radio(q, ["Yes", "No"], key=f"cq1_{i}")
                answers1[q] = ans
                answers1[f"cq1_{i}"] = ans   # store numbered key
            # summary flag for the whole stage
            answers1["cq1"] = "Yes" if any(v == "Yes" for k, v in answers1.items() if k.startswith("cq1_")) else "No"

            # ---- legal (form-only) submit handling ----
            _in_explore   = bool(st.session_state.get("peer_explore_mode"))
            _peer_name    = str(st.session_state.get("peer_explore_key", "")).strip()
            _peer_disp    = _peer_name.title() if _peer_name else "this condition"
            _closest      = st.session_state.get("_explore_prev_best_condition")  # may be None
            _has_alt      = bool(_closest) and _closest.strip().lower() != _peer_name.strip().lower()
            _obvious_fail = _in_explore and (answers1["cq1"] == "No")

            cont = st.form_submit_button("Continue →")
            view_closest = st.form_submit_button(f"View {_closest}") if (_obvious_fail and _has_alt) else False
            try_another  = st.form_submit_button("Try another path")  if _obvious_fail else False

            if view_closest:
                # switch Explore context to the suggested condition and rerun CQs
                st.session_state["peer_explore_mode"] = True
                st.session_state["peer_explore_key"]  = str(_closest).strip().lower()
                if "cq1_done" in st.session_state:
                    del st.session_state["cq1_done"]
                st.rerun()

            elif try_another:
                # exit Explore and go back one step
                st.session_state["peer_explore_mode"] = False
                st.session_state["peer_explore_key"]  = ""
                if "cq1_done" in st.session_state:
                    del st.session_state["cq1_done"]
                st.session_state.page = "symptom_subcategory"
                st.rerun()

            elif cont:
                # store CQ1 answers for later merge or checks
                st.session_state.user_data["answers1"] = answers1
                if _obvious_fail:
                    st.warning(
                        f"Your answers don’t match {_peer_disp}. "
                        + (f"Check the condition below based on your original triage: {_closest}"
                           if _has_alt else
                           "There isn’t a closer condition in this pathway.")
                    )
                    # Do not advance; user should pick one of the two submit buttons above
                else:
                    # normal path continues (move to Stage 2)
                    st.session_state.cq1_done = True
                    st.rerun()

        # Back takes you up one step (category or free-text)
        if st.button("← Back"):
            st.session_state.page = (
                "symptom_primary_category_freeinput"
                if st.session_state.get("free_input_mode", False)
                else "symptom_subcategory"
            )
            st.rerun()
        return

    # 3️⃣ Stage 2: only if any CQ1 was “Yes”
    answers1 = st.session_state.user_data.get("answers1", {})
    if any(v == "Yes" for v in answers1.values()):
        cq2s     = list(subset["Clarifying Questions2"].dropna().unique())
        answers2 = {}
        with st.form("cq2_form"):
            for j, q in enumerate(cq2s, 1):
                ans = st.radio(q, ["Yes", "No"], key=f"cq2_{j}")
                answers2[q] = ans
                answers2[f"cq2_{j}"] = ans   # store numbered key
            # summary flag for the whole stage
            answers2["cq2"] = "Yes" if any(v == "Yes" for k, v in answers2.items() if k.startswith("cq2_")) else "No"

            # ---- legal (form-only) submit handling ----
            _in_explore   = bool(st.session_state.get("peer_explore_mode"))
            _peer_name    = str(st.session_state.get("peer_explore_key", "")).strip()
            _peer_disp    = _peer_name.title() if _peer_name else "this condition"
            _closest      = st.session_state.get("_explore_prev_best_condition")  # may be None
            _has_alt      = bool(_closest) and _closest.strip().lower() != _peer_name.strip().lower()

            # ✅ RULE-AWARE EXPLORE CHECK (tiny change)
            # If we are exploring a single condition, decide "obvious fail" using:
            #   - CQ2 requirement for THAT row (only if LR mentions cq2), and
            #   - the row's Labeling Rule itself.
            if _in_explore and not subset.empty:
                picked_row = subset.iloc[0]  # Explore lock guarantees single row
                # normalize CQ answers so lookups are robust
                _merged = {**answers1, **answers2}
                # keep a normalized copy in session (keys are the raw questions)
                _answers = { _norm(k): v for (k, v) in _merged.items() }
                st.session_state.user_data["clarifying_answers"] = _merged  # original structure preserved

                _cq2_ok  = _row_cq2_eligible(picked_row, _answers)
                _rule_ok = evaluate_rule(picked_row["Labeling Rule"], picked_row, st.session_state.user_data, phase="selection")
                _obvious_fail = (not _cq2_ok) or (not _rule_ok)
            else:
                # legacy summary check if not in Explore mode
                _obvious_fail = False  # normal flow proceeds to risk flags

            cont2 = st.form_submit_button("Continue →")
            view_closest2 = st.form_submit_button(f"View {_closest}") if (_obvious_fail and _has_alt) else False
            try_another2  = st.form_submit_button("Try another path")  if _obvious_fail else False

            if view_closest2:
                st.session_state["peer_explore_mode"] = True
                st.session_state["peer_explore_key"]  = str(_closest).strip().lower()
                if "cq1_done" in st.session_state:
                    del st.session_state["cq1_done"]
                st.rerun()

            elif try_another2:
                st.session_state["peer_explore_mode"] = False
                st.session_state["peer_explore_key"]  = ""
                if "cq1_done" in st.session_state:
                    del st.session_state["cq1_done"]
                st.session_state.page = "symptom_subcategory"
                st.rerun()

            elif cont2:
                merged = {**answers1, **answers2}
                st.session_state.user_data["clarifying_answers"] = merged

                if _obvious_fail:
                    st.warning(
                        f"Your answers don’t match {_peer_disp}. "
                        + (f"Here’s the closest condition from your original triage: {_closest}"
                           if _has_alt else
                           "There isn’t a closer condition in this pathway.")
                    )
                    # Do not advance; user should pick one of the two submit buttons above
                else:
                    # proceed to Risk Flags
                    st.session_state.page = "risk_flag_selection"
                    if "cq1_done" in st.session_state:
                        del st.session_state.cq1_done
                    st.rerun()

        # Back goes back into Stage 1
        if st.button("← Back"):
            if "cq1_done" in st.session_state:
                del st.session_state.cq1_done
            st.rerun()
        return

    # 4️⃣ No “Yes” in CQ1: skip straight to risk flags
    st.session_state.user_data["clarifying_answers"] = answers1

    # (If you previously cleared peer-explore flags here, keep them commented to let Explore stick into Risk Flags.)
    # st.session_state["peer_explore_mode"] = False
    # st.session_state["peer_explore_key"]  = ""

    # NOTE: This block is OUTSIDE any form, so st.button is legal
    if st.session_state.get("peer_explore_mode"):
        any_yes = any(v == "Yes" for k, v in answers1.items() if k.startswith("cq"))
        if not any_yes:
            peer_name = str(st.session_state.get("peer_explore_key", "")).strip()
            peer_name_disp = peer_name.title() if peer_name else "this condition"
            closest = st.session_state.get("_explore_prev_best_condition")

            if closest and closest.strip().lower() != peer_name.strip().lower():
                st.warning(
                    f"Your answers don’t match {peer_name_disp}. "
                    f"Here’s the closest condition from your original triage: {closest}"
                )
                colA, colB = st.columns(2)
                with colA:
                    if st.button(f"View {closest}"):
                        st.session_state["peer_explore_mode"] = True
                        st.session_state["peer_explore_key"]  = str(closest).strip().lower()
                        if "cq1_done" in st.session_state:
                            del st.session_state["cq1_done"]
                        st.rerun()
                with colB:
                    if st.button("Try another path"):
                        st.session_state["peer_explore_mode"] = False
                        st.session_state["peer_explore_key"]  = ""
                        if "cq1_done" in st.session_state:
                            del st.session_state["cq1_done"]
                        st.session_state.page = "symptom_subcategory"
                        st.rerun()
                st.stop()
            else:
                st.warning(
                    f"Your answers don’t match {peer_name_disp}. "
                    "There isn’t a closer condition in this pathway."
                )
                if st.button("Try another path"):
                    st.session_state["peer_explore_mode"] = False
                    st.session_state["peer_explore_key"]  = ""
                    if "cq1_done" in st.session_state:
                        del st.session_state["cq1_done"]
                    st.session_state.page = "symptom_subcategory"
                    st.rerun()
                st.stop()

    if "cq1_done" in st.session_state:
        del st.session_state.cq1_done
    st.session_state.page = "risk_flag_selection"
    st.rerun()



# Helper: Show "No Match" message and safe next steps
def show_no_match_ui():
    # New heading for this screen
    st.subheader("We couldn’t safely identify a match.")

    # Explanatory message
    st.markdown(
        """
        <div style="
            background:#f8d7da;
            border:1px solid #f5c6cb;
            color:#58151c;
            border-radius:10px;
            padding:14px 16px;
            margin:8px 0 12px;
            font-size:1.05rem;
            line-height:1.6;
            font-weight:600;">
            <span style="font-size:1.2rem; font-weight:700;">
            Your symptoms may still need attention.
            Your initial symptoms didn’t meet the labeling rule for a clear condition; 
            despite some overlap, they’re not sufficient evidence to call it.
            <br><br>
            <span style="font-weight:700;">Next step:</span> 
            <span style="font-weight:600;">Speak to a clinician now</span> 
            or <span style="font-weight:600;">try a different path</span>.
           
        </div>
        """,
        unsafe_allow_html=True,
    )
    # Red-flag line (keeps same background for consistency)
    st.markdown(
        """
        <div style="
            background:#f8d7da;
            border:1px solid #f5c6cb;
            color:#58151c;
            border-radius:10px;
            padding:12px 14px;
            margin:0 0 12px;">
            <strong>If you have any of these, go to emergency care now:</strong>
            severe or fast-worsening pain, trouble breathing, chest pain,
            heavy bleeding, fainting/confusion, or (for children) fast-worsening symptoms.
        </div>
        """,
        unsafe_allow_html=True,
    )    

    # CTAs
    col1, col2 = st.columns(2)
    with col1:
        if st.button("📅Get help/Schedule a Consultation", use_container_width=True):
            # TODO: swap this info() with your scheduling flow when ready
            st.info("Appointment scheduling flow will be implemented here.")
    with col2:
        if st.button("🔄 Start Over", use_container_width=True):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()

    # Small safety reminder
    st.markdown(
        "<div style='font-size:1.05rem; font-weight:700; color:#6b7280; margin-top:8px;'>"
        "⚠️  Remember- If symptoms worsen or red flags appear, seek EMERGENCY care."
        "</div>",
        unsafe_allow_html=True,
    )

# ─────────────────────────────────────────────


def risk_flag_selection_page():
    st.image(logo, width=80)
    #st.subheader("These factors can affect your care. Select any that apply, or “None.”")

    # 🔄 Clear any stale risk-flag checkbox state (including rf_none)
    

    # ── 1) Build the subset of candidate conditions ──
    cat    = st.session_state.user_data.get("primary_category")
    sub    = st.session_state.user_data.get("subcategory")
    source = (
        st.session_state.matched_conditions
        if st.session_state.get("free_input_mode", False)
        else db
    )
    subset = source[
        (source["Primary Category"] == cat) &
        (source["SubCategory"]      == sub)
    ]
    if subset.empty:
        st.error("No conditions found here—please start over.")
        return
    
    # PRECOMPUTE the original best condition for "closest condition" fallback
    # Recompute whenever the explored key changes, and never pick the explored condition itself.
    _peer_key_norm = str(st.session_state.get("peer_explore_key", "")).strip().lower()
    if st.session_state.get("peer_explore_mode") and _peer_key_norm:
        if st.session_state.get("_explore_prev_key") != _peer_key_norm:
            def _rank_key_local(r):
                conf = str(r.get("Labeling Confidence", "Low")).lower()
                conf_rank = {"high": 2, "medium": 1, "low": 0}.get(conf, 0)
                acu = int(r.get("Acuity Level", 1) or 1)
                rule_len = len(str(r.get("Labeling Rule", "")))
                name = str(r.get("Condition", ""))
                return (-conf_rank, -acu, rule_len, name)

            base_ranked = (
                subset.assign(__rk=subset.apply(_rank_key_local, axis=1))
                      .sort_values("__rk", ascending=True)
            )

            closest = None
            if not base_ranked.empty:
                for c in base_ranked["Condition"].astype(str):
                    c_norm = c.strip().lower()
                    if c_norm != _peer_key_norm:
                        closest = c.strip()
                        break

            st.session_state["_explore_prev_best_condition"] = closest  # may be None
            st.session_state["_explore_prev_key"] = _peer_key_norm


    # --- PEER EXPLORE LOCK: if we arrived via Explore, restrict to that single condition ---
    if st.session_state.get("peer_explore_mode") and st.session_state.get("peer_explore_key"):
        _peer_key = st.session_state["peer_explore_key"].strip().lower()
        subset = subset[subset["Condition"].astype(str).str.strip().str.lower() == _peer_key]
        # Defensive fallback: if nothing matches, drop the lock and proceed normally
        if subset.empty:
            st.session_state["peer_explore_mode"] = False
            st.session_state["peer_explore_key"]  = ""

    # Clear any stale risk selections before evaluating rules
    st.session_state.user_data["confirmed_risks"] = []
    
    # 3️⃣ Prefer rows whose Labeling Rule passes for this user
    subset = subset.copy()
    
    def _passes(row):
        return evaluate_rule(row.get("Labeling Rule",""), row, st.session_state.user_data, phase="selection")

    subset["rule_ok"] = subset.apply(_passes, axis=1)
    candidates = subset[subset["rule_ok"]]

    if candidates.empty:
        # show the new heading here (and the CTAs in the helper)
        #st.subheader("Unfortunately, we haven’t found a match yet.")
        show_no_match_ui()
        return
    else:
        st.subheader("These factors can affect your care. Select any that apply, or “None.”")
        subset = candidates

    # HARD-GATE: do not fall back to the original subset if empty
    if candidates.empty:
        show_no_match_ui()
        return
    else:
        subset = candidates

    # (Optional) Skip "Low" confidence rows entirely; remove this block if you prefer to keep them
    subset = subset[subset["Labeling Confidence"].str.lower().ne("low")]
    if subset.empty:
        show_no_match_ui()
        return

    # Ranking function used for tie-breaks

    
    def _rank_key(r):
        conf = str(r.get("Labeling Confidence", "Low")).lower()
        conf_rank = {"high": 2, "medium": 1, "low": 0}.get(conf, 0)
        acu = int(r.get("Acuity Level", 1) or 1)
        rule_len = len(str(r.get("Labeling Rule", "")))
        name = str(r.get("Condition", ""))
        # Sort: higher confidence, higher acuity, shorter rule, A→Z
        return (-conf_rank, -acu, rule_len, name)

    # Sort by a single helper column that holds the tuple (lexicographic order)
    subset = (
        subset
        .assign(__rk=subset.apply(_rank_key, axis=1))
        .sort_values("__rk", ascending=True)
        .drop(columns="__rk")
    )

    # ── 2) Map CQ2 “Yes” answers back to rows (normalized) ──
    answers = st.session_state.user_data.get("clarifying_answers", {}) or {}

    def _norm(s):
        return str(s).strip()

    # Normalize saved answers’ keys to avoid whitespace/case mismatches
    answers = { _norm(k): v for (k, v) in answers.items() }
    st.session_state.user_data["clarifying_answers"] = answers  # keep consistent downstream

    # Build the set of CQ2s present in THIS subset (normalized)
    asked_q2 = list(subset["Clarifying Questions2"].dropna().unique())
    asked_q2_norm = { _norm(q) for q in asked_q2 }

    # Rebuild flagged using normalized lookups (row is "flagged" if its own CQ2 == "Yes")
    flagged = []
    for idx, row in subset.iterrows():
        q2 = _norm(row.get("Clarifying Questions2", ""))
        if q2 and answers.get(q2) == "Yes":
            flagged.append(idx)

    # Was a CQ2 asked in this interaction for this pool?
    cq2_was_asked = len(asked_q2_norm & set(answers.keys())) > 0

    # ── 3) Triaging logic (Require CQ2 only if the row's rule requires it) ──
    import re
    _requires_cq2_re = re.compile(r"\bcq2\b", flags=re.IGNORECASE)

    def _requires_cq2(rule_text: str) -> bool:
        # A row "requires CQ2" only if its Labeling Rule explicitly references cq2
        return bool(_requires_cq2_re.search(str(rule_text)))

    # Mark rows that require cq2 per their rule
    requires_flags = subset["Labeling Rule"].map(_requires_cq2).astype(bool)

    # Build eligible set:
    #  • Rows whose rules do NOT require cq2  → eligible regardless of CQ2 answer
    #  • Rows whose rules DO require cq2      → eligible only if their own CQ2 == "Yes" (i.e., in `flagged`)
    eligible_idx = set(subset.index[~requires_flags])   # rules NOT requiring cq2
    eligible_idx.update(flagged)                        # add rows that DO require cq2 and were CQ2-Yes

    # Safety: if CQ2 was asked and nothing is eligible, show "No match" instead of defaulting
    if cq2_was_asked and len(eligible_idx) == 0:
        show_no_match_ui()
        return

    # If exactly one row in the pool and its rule does NOT require cq2 → allow selection even if CQ2 = No
    if len(subset) == 1:
        only_idx = subset.index[0]
        if not requires_flags.loc[only_idx]:
            chosen_idx = only_idx
            # ↓ do NOT return here; we still want the "Save the final condition" block to run just below
        else:
            # Single row but it requires CQ2 and wasn't eligible → handled by the no-match guard above
            pass

    # Choose among eligible rows (preferred), otherwise fall back to legacy only when CQ2 wasn’t asked
    if len(eligible_idx) > 0:
        df_eligible = subset.loc[list(eligible_idx)].copy()
        df_eligible = (
            df_eligible
            .assign(__rk=df_eligible.apply(_rank_key, axis=1))
            .sort_values("__rk", ascending=True)
        )
        chosen_idx = df_eligible.index[0]
    else:
        # CQ2 not asked in this path → legacy behavior
        if len(flagged) == 1:
            chosen_idx = flagged[0]
        elif len(flagged) > 1:
            df_flagged = subset.loc[flagged].copy()
            df_flagged = (
                df_flagged
                .assign(__rk=df_flagged.apply(_rank_key, axis=1))
                .sort_values("__rk", ascending=True)
            )
            chosen_idx = df_flagged.index[0]
        else:
            subset_ranked = (
                subset
                .assign(__rk=subset.apply(_rank_key, axis=1))
                .sort_values("__rk", ascending=True)
            )
            chosen_idx = subset_ranked.index[0]



    # ── 4) Save the final condition ──
    st.session_state.current_condition = subset.loc[chosen_idx]
    # One-time reset of risk-flag checkboxes when the chosen condition changes
    cc_id = str(st.session_state.current_condition.get("Condition", "")).strip()
    if st.session_state.get("rf_ctx") != cc_id:
        for k in list(st.session_state.keys()):
            if isinstance(k, str) and k.startswith("rf_"):
                del st.session_state[k]
        st.session_state["rf_ctx"] = cc_id

    # ── 5) Render its RiskFlags ──
    cond = st.session_state.current_condition
    raw = str(cond.get("RiskFlags", "") or "")
    flags = [f.strip() for f in raw.split(",") if f.strip()]

    selected = []
    for flag in flags:
        if st.checkbox(flag, key=f"rf_{flag}"):
            selected.append(flag)

    none = st.checkbox("None / Not Applicable", key="rf_none")
    if none and selected:
        st.warning("“None” cannot be combined with other selections; only “None” will be used.")

    # ── 6) Continue → record and go to Results ──
    if st.button("Continue"):
        chosen = [] if none else selected
        # Save to both canonical session_state and user_data
        st.session_state.confirmed_risks = list(chosen)
        st.session_state.user_data["confirmed_risks"] = list(chosen)

        # Clear peer-explore lock now that RFs are done for this condition
        st.session_state["peer_explore_mode"] = False
        st.session_state["peer_explore_key"]  = ""
        st.session_state.pop("_explore_prev_best_condition", None)  
        st.session_state.pop("_explore_prev_key", None)           

        st.session_state.page = "results"
        st.rerun()

    # ← Back → clarifiers
    if st.button("← Back"):
        st.session_state.page = "clarifying_questions"
        st.rerun()



import re

# REPLACE your evaluate_rule with this
def evaluate_rule(rule_str: str, condition: dict, user_data: dict, *, phase: str = "selection") -> bool:
    """
    Evaluate Labeling Rule against the user's inputs.
    phase="selection": ignore risk_flag atoms so valid rows aren't blocked pre-pick
    phase="results":   enforce risk_flag atoms normally
    """
    import re

    sel_syms = {s.strip().lower() for s in user_data.get("selected_symptoms", []) if isinstance(s, str)}
    sel_rfs  = {r.strip().lower() for r in user_data.get("confirmed_risks", []) if isinstance(r, str)}
    answers  = {str(k).lower(): str(v).strip().lower()
                for k, v in user_data.get("clarifying_answers", {}).items()}

    cq1_any = any((k.startswith("cq1_") and v == "yes") for k, v in answers.items())
    cq2_any = any((k.startswith("cq2_") and v == "yes") for k, v in answers.items())
    answers["cq1"] = "yes" if cq1_any else "no"
    answers["cq2"] = "yes" if cq2_any else "no"

    def eval_atom(atom: str) -> bool:
        atom = atom.strip()
        m = re.match(r"^symptom\s*==\s*(.+)$", atom, re.IGNORECASE)
        if m:
            return m.group(1).strip().lower() in sel_syms
        m = re.match(r"^risk_flag\s*==\s*(.+)$", atom, re.IGNORECASE)
        if m:
            v = m.group(1).strip().lower()
            return True if phase == "selection" else (v in sel_rfs)
        m = re.match(r"^cq(\d+)\s*==\s*yes$", atom, re.IGNORECASE)
        if m:
            n = m.group(1)
            if answers.get(f"cq{n}", "") == "yes":
                return True
            return any(k.startswith(f"cq{n}_") and v == "yes" for k, v in answers.items())
        return False

    parts = re.split(r"(\bAND\b|\bOR\b|\(|\))", str(rule_str or ""), flags=re.IGNORECASE)
    expr = ""
    for t in parts:
        t = t.strip()
        if not t: continue
        if re.fullmatch(r"AND", t, re.IGNORECASE):
            expr += " and "
        elif re.fullmatch(r"OR", t, re.IGNORECASE):
            expr += " or "
        elif t in ("(", ")"):
            expr += t
        else:
            expr += str(eval_atom(t))
    try:
        return bool(eval(expr)) if expr else False
    except Exception:
        return False



def make_recommendation(condition: dict, user_flags: dict, risk_flags: list) -> str:
    # Determine escalation — normalize acuity to int
    raw_acuity = condition.get("Acuity Level", 0)
    try:
        acuity = int(raw_acuity or 0)
    except Exception:
        acuity = 0

    is_esc = bool(risk_flags) or (acuity == 3)

    # Confidence guard
    conf = condition.get("Labeling Confidence", "Low")
    if conf == "Low":
        return ""

    # Rule match guard (allow escalation)
    rule_ok = evaluate_rule(condition["Labeling Rule"], condition, st.session_state.user_data, phase="results")


    # ⬅ NEW: enforce rule before building recommendation
    if not rule_ok and not is_esc:
        return ""

    # Certainty phrase
    certainty = "very likely" if conf == "High" else "symptoms suggest"

    # Pick templates
    if is_esc:
        base_tmpl = condition.get("Escalated Narrative Template (Risk Flags Present)", "")
        rec_text = condition.get("Escalated Recommendation", "")
    else:
        base_tmpl = condition.get("Default Narrative Template", "")
        rec_text = condition.get("Default Recommendation", "")

    # Render base with placeholders
    base = base_tmpl.format(
        certainty=certainty,
        risk_flags=", ".join(risk_flags),
        default_rec=condition.get("Default Recommendation", ""),
        escalated_rec=condition.get("Escalated Recommendation", "")
    )

    # Build recommendation without duplication
    if ('{default_rec}' in base_tmpl) or ('{escalated_rec}' in base_tmpl):
        recommendation = base
    else:
        recommendation = f"{base} {rec_text}".strip()

     #Append emergency note marker
    note = condition.get("Emergency (Time-critical) Narrative (If Applicable)", "").strip()
    if note:
        recommendation += f"\n\n🚨 Important: {note}"

    return recommendation


def results_page():
    # Header and Title
    st.image(logo, width=80)
    #st.header("Based on your answers, your likely condition is:")

    # Fetch the chosen condition
    condition = st.session_state.current_condition
    if condition is None:
        st.error("No condition selected. Please start over.")
        if st.button("🔄 Start New Check"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
        return

    # Show the condition's name
    #condition_title = condition.get("Condition", "")
    #st.subheader(condition_title)

    # --- Determine baseline acuity for the chosen condition only ---
    try:
        baseline_rank = int(condition.get("Acuity Level", 0) or 0)
    except Exception:
        baseline_rank = 0

    # --- Gather & sanitize risk flags (prefer session_state, fallback to user_data) ---
    raw_flags = st.session_state.get(
        "confirmed_risks",
        st.session_state.user_data.get("confirmed_risks", [])
    )
    risk_flags = [rf.strip() for rf in (raw_flags or []) if isinstance(rf, str) and rf.strip()]

    # --- Escalation logic: red if acuity==3 or any risk flag chosen ---
    is_esc = (baseline_rank == 3) or bool(risk_flags)
    block_class = "report-block" if is_esc else "report-block report-block--ok"

    # ——— Assemble user_flags with normalized keys ———
    user_data  = st.session_state.user_data
    user_flags = {}

    # 1) Symptoms from selected_symptom
    for sym in user_data.get("selected_symptoms", []):
        key = sym.strip().lower().replace(" ", "_")
        user_flags[key] = True

    # 2) Clarifiers from clarifying_answers
    for question, ans in user_data.get("clarifying_answers", {}).items():
        if ans == "Yes":
            key = question.strip().lower().replace(" ", "_")
            user_flags[key] = True

    # 3) Risk flags
    for rf in risk_flags:
        key = rf.strip().lower().replace(" ", "_")
        user_flags[key] = True

    # Generate recommendation (string may include an appended emergency line in older builds)
    recommendation = make_recommendation(condition, user_flags, risk_flags)

    if recommendation:
        # ✅ Only show headline when recommendation exists
        st.header("Based on your answers, your likely condition is:")

        # ⬇️ Move these two lines here
        condition_title = condition.get("Condition", "")
        st.subheader(condition_title)
    
    else:
        fallback_html = """
        <div style="
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            border-radius: 12px;
            padding: 24px;
            font-size: 1.25rem;
            line-height: 1.6;
            color: #3a2e00;
            font-weight: 500;
            text-align: center;
        ">
            I couldn’t make a confident match for your symptoms.<br>
            That happens sometimes, and it simply means a human touch is needed.<br>
            <strong>Consider reaching out to a healthcare professional — or you can try another check with more details.</strong>
        </div>
        """
        st.markdown(fallback_html, unsafe_allow_html=True)

        # Add space before buttons
        st.markdown("<div style='margin-top: 20px;'></div>", unsafe_allow_html=True)

        col1, col2 = st.columns(2)
        with col1:
            if st.button("🔄 Start Over", use_container_width=True):
                st.session_state.clear()
                st.session_state.page = "welcome"
                st.rerun()
        with col2:
            if st.button("📅 Schedule a Consultation", use_container_width=True):
                st.info("Appointment scheduling flow will be implemented here.")
        return

    # Display recommendation or fallback with styled blocks
    if recommendation:
        # Your escalation rule for card color:
        is_esc = (baseline_rank == 3) or bool(risk_flags)
        block_class = "report-block" if is_esc else "report-block report-block--ok"

        # If the recommendation string contains an appended emergency line,
        # strip it from the main text to avoid duplication (we render emergency separately).
        parts = recommendation.split('\n\n🚨 Important: ')
        main_text = parts[0].strip()

        # MAIN CARD (escape DB content)
        safe_main = html.escape(main_text).replace('\n','<br>')
        card_html = (
            f"<div class='{block_class}' style='font-size: 1.2rem;'>"
            f"{safe_main}"
            "</div>"
        )

        

        st.markdown(card_html, unsafe_allow_html=True)

        # EMERGENCY NOTE — render once, as a separate block
        emergency = (condition.get("Emergency Narrative (If Applicable)", "") or "").strip()
        if emergency:
            st.markdown(
                f"<div class='emergency-block' style='font-size: 1.2rem; margin-bottom: 20px;'>"
                f"🚨 Important: {html.escape(emergency)}</div>",
                unsafe_allow_html=True
        )

        # --- Result page: local styles for cleaner look (scoped) ---
        st.markdown("""
        <style>
        /* Scope styles to the peers section only */
        .peers-wrap h3 {
          margin: 0 0 2px 0;
          font-size: 1.2rem;
          line-height: 1.35;
        }
        .peers-wrap p {
          margin: 0 0 10px 0;
          font-size: 1.05rem;
          opacity: 0.9;
        }
        .peers-buttons {
          display: flex;
          flex-wrap: wrap;
          gap: 8px;
        }
        .peers-buttons .stButton > button {
          font-size: 0.98rem;
          padding: 0.45em 0.9em;
          border-radius: 8px;
        }
        @media (max-width: 640px) {
          .peers-buttons .stButton > button { width: 100% !important; }
        }
        </style>
        """, unsafe_allow_html=True)

        # === Similar conditions (same subcategory) ===
        try:
            primary  = str(condition.get("Primary Category", "")).strip()
            subcat   = str(condition.get("SubCategory", "")).strip()
            current  = str(condition.get("Condition", "")).strip()
            age      = st.session_state.user_data.get("age")
            gender   = st.session_state.user_data.get("gender")

            # 1) Pull peers from same primary + subcategory
            peers = db[(db["Primary Category"].astype(str).str.strip() == primary) &
                       (db["SubCategory"].astype(str).str.strip() == subcat)].copy()

            # Exclude the current condition
            peers = peers[peers["Condition"].astype(str).str.strip() != current]

            # Age gate (hide pediatrics for adults) + gender-aware filtering
            if (age is not None) and (age >= 15):
                peers = peers[~peers["Primary Category"].astype(str).apply(lambda c: "pediatrics" in _cat_norm(c))]
            if gender:
                peers = peers[peers.apply(lambda r: _row_allowed_for_gender(r, gender), axis=1)]

            # 2) Rank peers: (a) symptom overlap → (b) same acuity tie-break → (c) alphabetical
            sel_syms = {
                s.strip().lower()
                for s in st.session_state.user_data.get("selected_symptoms", [])
                if isinstance(s, str) and s.strip()
            }
            try:
                cur_acuity = int(condition.get("Acuity Level", 0) or 0)
            except Exception:
                cur_acuity = 0

            def _overlap_score(row):
                row_syms = {
                    s.strip().lower()
                    for s in str(row.get("Symptoms", "")).split(",")
                    if s and s.strip()
                }
                return len(sel_syms & row_syms)

            def _same_acuity(row):
                try:
                    return 1 if int(row.get("Acuity Level", 0) or 0) == cur_acuity else 0
                except Exception:
                    return 0

            if not peers.empty:
                peers = (
                    peers.assign(
                        _overlap=peers.apply(_overlap_score, axis=1),
                        _acuity_tie=peers.apply(_same_acuity, axis=1)
                    )
                    .sort_values(by=["_overlap", "_acuity_tie", "Condition"], ascending=[False, False, True])
                )

                # Compact display names, top 5
                names = (
                    peers["Condition"]
                    .dropna()
                    .astype(str)
                    .map(str.strip)
                    .drop_duplicates()
                    .tolist()
                )[:3]

                if names:
                    # Clean header (no green canvas), slightly larger fonts
                    st.markdown(
                        "<div class='peers-wrap'>"
                        "<h3>More conditions in this subcategory</h3>"
                        "<p>Explore related options that share similar features.</p>"
                        "</div>",
                        unsafe_allow_html=True
                    )

                   
                    # Render compact list with overlap + smarter Explore routing
                    st.markdown("<div class='peers-buttons'>", unsafe_allow_html=True)
                    for nm in names:
                        row = peers[peers["Condition"].astype(str).str.strip() == nm].iloc[0]

                        # Compute overlap against user-selected symptoms
                        sel_syms = {
                            s.strip().lower()
                            for s in st.session_state.user_data.get("selected_symptoms", [])
                            if isinstance(s, str) and s.strip()
                        }
                        row_syms = {
                            s.strip().lower()
                            for s in str(row.get("Symptoms", "")).split(",")
                            if s and s.strip()
                        }
                        ov = sorted(list(sel_syms & row_syms))
                        matched = f"Matched {len(ov)} of your symptoms" if ov else "Shares similar features"
                        keywords = f" ({', '.join(ov[:3])})" if ov else ""

                        # Name + overlap line
                        st.markdown(
                            f"<div style='margin:6px 0 2px; font-weight:700;'>{html.escape(nm)}</div>"
                            f"<div style='margin:0 0 8px; font-size:0.95rem; opacity:0.9;'>"
                            f"{html.escape(matched)}{html.escape(keywords)}</div>",
                        unsafe_allow_html=True
                        )

                        if st.button(f"🔍 Explore {nm}", key=f"qc_explore_{nm}"):
                            st.session_state.current_condition = row
                            # Tell the CQ page we arrived via Explore and which row to lock to
                            st.session_state["peer_explore_mode"] = True
                            st.session_state["peer_explore_key"]  = str(row.get("Condition","")).strip()

                            # Reset any clarifier state from the previous condition
                            st.session_state.user_data.pop("answers1", None)
                            st.session_state.user_data.pop("answers2", None)
                            st.session_state.user_data.pop("clarifying_answers", None)
                            st.session_state.pop("cq1_done", None)

                            # Always re-ask CQ for the explored condition
                            st.session_state.page = "clarifying_questions"
                            st.rerun()
                    st.markdown("</div>", unsafe_allow_html=True)
        except Exception:
            # Fail silently so the Results page never breaks
            pass


        # Optional referral line below the card (escape too)
        ref_text = (condition.get("Referral", "") or "").strip()
        if ref_text:
            st.markdown(
                f"<div class='referral-block' style='font-size: 1.1rem; margin: 6px 0 18px;'>"
                f"🩺 <strong>{html.escape(ref_text)}</strong></div>",
                unsafe_allow_html=True
            )

    else:
        # Fallback amber (mobile-friendly)
        warn_html = (
            "<div class='report-block report-block--warn'>"
            "I’m not able to match a condition confidently. Please consider consulting a "
            "healthcare professional for a definitive evaluation."
            "</div>"
        )
        st.markdown(warn_html, unsafe_allow_html=True)

    # Optional: Schedule Appointment button
    if condition.get("Referral") and st.button("📅 Schedule a Consultation or Get Help"):
        st.info("Appointment scheduling will be available soon.")

    # Download report & New Check buttons (single set; CSS centers on mobile only)
    col1, col2 = st.columns([1, 1])

    with col1:
        report_text = generate_report()
        st.download_button(
            label="📄 Download Full Report",
            data=report_text,
            file_name=f"{condition_title}_report.txt",
            key="dl_report"
        )

    with col2:
        if st.button("🔄 Start New Check", key="newcheck"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()

   # ⬇️ CSS comes immediately after these buttons
    st.markdown("""
    <style>
    @media (max-width: 640px) {
      /* Center the download button itself */
      div[data-testid="stDownloadButton"] > button {
        display: block !important;
        margin-left: auto !important;
        margin-right: auto !important;
      }
    }
    </style>
    """, unsafe_allow_html=True)



def fallback_page():
    st.image(logo, width=80)
    st.warning("I couldn’t find a clear match for your symptoms, which could mean they’re mild or need professional evaluation.")
    st.markdown("**Would you like to speak with a Doctor about this?**")
    col1, col2, col3 = st.columns([1,1,1])
    with col1:
        if st.button("📅 Schedule a Consultation"):
            st.info("Appointment scheduling flow will be implemented here.")
    with col2:
        if st.button("🔄 Start Over"):
            st.session_state.clear()
            st.session_state.page = "welcome"
            st.rerun()
    with col3:
        if st.button("← Back"):
            st.session_state.page = "clarifying_questions"
            st.rerun()

PAGES = {
    "welcome": welcome_page,
    "user_info": user_info_page,
    "symptom_category": symptom_category_page,
    "symptom_free_input": symptom_free_input_page,
    "symptom_primary_category_freeinput": symptom_primary_category_freeinput_page,
    "symptom_subcategory": symptom_subcategory_page,
    "symptom_selection": symptom_selection_page,
    "clarifying_questions": clarifying_questions_page,
    "risk_flag_selection": risk_flag_selection_page,
    "results": results_page,
    "fallback_page": fallback_page,
    "analytics": analytics_page,
}
# ---- Auth gate: show login until authenticated ----
if not st.session_state.get("logged_in", False):
    login_page()
    st.stop()

PAGES[st.session_state.page]()